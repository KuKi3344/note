## 浏览器是如何工作的

### 关于浏览器内核

浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。

浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分的，一是渲染引擎，另一个是JS引擎。渲染引擎在不同的浏览器中也不是都相同的。

主流浏览器：IE/Edge，Chrome，Safari，Opera，Firefox![](https://pic3.zhimg.com/80/v2-f464eaf0dc47177ef67649c1c1eb6e22_720w.jpg)

### 关于访问一个网址的过程

当我们启动某个程序时，就会创建一个进程来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里，当应用关闭时，该内存空间就会被回收，进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递某些数据，则需要通过进程间通信管道IPC来传递，很多应用程序都是多进程的结构，这样是为了避免某一个进程卡死，由于进程间相互独立，这样不会影响到整个应用程序。

进程可以将任务分成更多细小的任务，然后通过创建多个线程并行执行不同任务，同一进程下的线程之间是可以直接通信共享数据的。

早期浏览器并不是多进程结构热而是单进程的结构。一个进程中大概有页面线程负责页面渲染和展示等，js线程执行js代码，还有其中各种线程。单进程的结构引发的许多问题，一是**不稳定**，其中一个线程卡死会导致整个进程出问题。比如打开多个标签页，其中一个标签卡死可能会导致整个浏览器无法正常运行，二是**不安全**，浏览器之间是可以共享数据的，那JS线程就可以随意访问浏览器进程内的所有数据。（同一进程下线程之间共享数据）三是**不流畅**，一个进程负责太多事情会导致运行效率的问题。

现在采用多进程浏览器结构，根据进程功能不同来拆卸浏览器

以下拿谷歌浏览器举例子

![1](D:\web前端\web note\img\1.png)

我们可以将它分解成这样的结构

浏览器进程：负责控制浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其它进程协调工作。

网络进程：负责发起接受网络请求

GPU进程：负责整个浏览器界面的渲染

插件进程：负责控制网站使用的所有插件，如 flash

渲染器进程：用来控制显示tab标签内的所有内容，浏览器在默认情况下会为每个标签页都创建一个进程。

**当我们在浏览器地址栏输入内容时，浏览器内部会发生什么事情**

当我们在浏览器地址栏输入内容时，浏览器进程的UI线程会捕捉你的输入内容，如果访问的是网址，则UI线程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器获取数据。如果你输入的不是网址，而是一串关键词，浏览器就知道你是要搜索，就会使用默认配置的搜索引擎来查询。

**网络线程获取到数据后会发生什么事情？**

当网络线程获取到数据后，会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会展示警示页面，会阻止你访问，当然也可以继续访问。SafeBrowsing 是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看该站点的IP是否在谷歌的黑名单之内。当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程要准备好了，然后UI线程会创建一个渲染器进程来渲染页面，浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程。渲染器进程接到的数据也就是html，渲染器进程的核心任务就是把html，css，js，image等资源渲染成用于可以交互的web页面，渲染器进程的主线程将html进行解析，构造DOM数据结构，DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过js与之交互的数据结构和API。html首先通过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造，在DOM树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素。html代码中往往会引入一些其它资源，比如图片，css，js脚本等，图片和css这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，因为她们不会影响DOM的生成，但当html解析过程中遇到script标签，就会停止html解析流程，转而去加载解析并执行js。**为什么要停止去加载js而不是等html加载结束后再加载运行js呢？**因为浏览器不知道js执行是否会改变当前页面的html结构，如果js代码里调用了`document.write`方法来修改html，那么之前的html解析就没有意义了。所以要把script标签放在合适的位置，或者使用async或defer属性来异步加载执行js。再html解析完成后，我们就会获得一个DOM树，但我们还不知道DOM树每一个节点应该长什么样子，主线程需要解析css，并确定每个DOM节点的计算样式。在知道DOM结构和每个节点的样式后，接下来需要知道每个节点放在页面上的哪个位置，也就是节点的坐标与占用区域，这个阶段被称为**Layout布局**，主线程通过遍历DOM和计算好的样式来生成`Layout tree`,Layout树上面每个节点都记录了x，y坐标和边框尺寸。**注：**DOM树和Layout树并不是一一对应的。设置了`display：none`的节点不会出现在Layout 树上。而在before伪类中添加了content值的元素，content里的内容会出现再Layout树上，不会出现在DOM树里，这是因为DOM是通过html解析获得，并不关系样式，而Layout树是通过DOM树和计算好的样式来生成，Layout树是和最后展示在屏幕上的节点是对应的。![2](D:\web前端\web note\img\2.png)

如图，左边为DOM树，右边为Layout树

知道这些后，我们还需要知道以什么样的顺序绘制这些节点，比如说`z-index`会影响节点绘制的层级关系，如果按照DOM的层级结构来绘制页面，则会导致错误的渲染。所以为了保证在屏幕上展示正确的层级，主线程遍历Layout树，创建一个绘制记录表（Paint Record），该表记录了绘制的顺序，这个阶段被称为**绘制**。知道了文档的绘制顺序，该把信息转化成像素点显示在屏幕上了，这种行为称为**栅格化**。主线程遍历Layout树生成Layer树，Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，合成器线程按照规则分图层，并将图层切割为许多个小图块然后将每个图块发送给栅格线程，栅格线程栅格化每个图块，并将它们存储在GPU内存中，当图块栅格化完成后，合成器线程将收集栅格线程传过来的称为`draw quads`的图块信息，这些信息里记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息，根据这些信息合成器线程生成了一个合成器帧，然后合成器帧(Frame)通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。这时候就会看到页面内容。当你的页面发生变化，比如滚动页面，就会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上。

当改变了一个元素的尺寸位置属性时，会重新进行样式计算，布局，绘制，以及后面的所有流程，这种行为称为**重排**。当我们改变某个元素的颜色属性，不会重新触发布局，但还是会触发样式计算和绘制，这叫**重绘**。重排和重绘都会占用主线程。

JS也是在主线程运行，这样就会出现抢占执行时间的问题。如果写了一个不断导致重拍重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。如果在运行动画时还有大量js任务需要执行，这些任务都是在主线程执行的，当在一帧时间内，布局和绘制结束后还有剩余时间，js就会拿到主线程的使用权，如果js执行时间过长，就会导致在下一帧开始时js没有及时归还主线程导致下一帧动画没有按时渲染，就会出现页面动画的卡顿。

**优化手段：**可以通过`requestAnimationFrame()`这个API来解决这个问题，这个方法会在每一帧被调用，通过API的回调，可以把js运行任务分成更小的任务块，在每一帧时间用完前暂停JS执行，归还主线程，这样在下一帧开始时，主线程就可以按时执行布局和绘制。

通过transform属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中js执行的影响，也节省了很多运算时间。

重排的代价是高昂的，会破坏用户体验，并且让UI展示非常迟缓。通过减少重排的负面影响来提高用户体验的最简单方式就是尽可能的减少重排次数，重排范围。

### 如何减少重排和重绘

- 尽量避免`style`的使用，对于需要操作`DOM`元素节点，重新命名`className`，更改`className`名称。

- 如果增加元素或者`clone`元素，可以先把元素通过[`documentFragment`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocumentFragment)放入内存中，等操作完毕后，再`appendChild`到`DOM`元素中。

- 不要经常获取同一个元素，可以第一次获取元素后，用变量保存下来，减少遍历时间。

- 尽量少使用`dispaly:none`，可以使用`visibility:hidden`代替，`dispaly:none`会造成**重排**，`visibility:hidden`会造成**重绘**。

- 不要使用`Table`布局，因为一个小小的操作，可能就会造成整个表格的**重排**或**重绘**。

- 使用`resize`事件时，做**防抖**和**节流**处理。

- 对动画元素使用`absolute / fixed`属性。

- 批量修改元素时，可以先让元素脱离文档流，等修改完毕后，再放入文档流。