# ES6



### let关键字

ES6中新增的用于声明变量的关键字

- let声明的变量旨在所处于的块级有效

```js
if(true){
let a = 10;
    if(true){
		let c = 30;
    }
    console.log(c);	//c is not defined
}
console.log(a); // a is not defined
```

在一个大括号中，使用let关键字声明的变量才具有块级作用域

var关键字是不具备这个特点的

```js
for (let i = 0;i < 2;i++){

}
cosole.log(i); 	// i is not defined

for (var i = 0;i < 2;i++){

}
cosole.log(i); 	// 2
```

拥有块级作用域的变量能带来的好处：防止循环变量变成全局变量

- 不存在变量提升

```js
console.log(a);
let a = 100;
```

- 暂时性死区特性

```js
var tmp = 123;
if(true){
	tmp = 'abc';
	let tmp;
}
```

虽然if语句外有同名变量，但是和块级作用域中的tmp是毫无关系的，它们之间不会相互影响，let定义的变量和块级这个整体进行了绑定，所以在变量声明的前面使用变量，会报错，报变量没有定义的错，这种特性叫暂时性死区。

#### 经典面试题

```js
var arr = [];
for (var i = 0;i < 2;i++){
		arr[i] = function(){
			console.log(i);
	}
}
// 注意：for循环只是往arr数组中添加函数而不是执行
arr[0]();	//由于arr[i]的值就是函数所以可以直接后面加()调用
arr[1]();
```

由于函数执行时，循环早就结束了，所以i的值是不满足循环条件的值。所以函数执行时输出的i值是2。由于数组中存储的两个函数在执行时输出的都是`全局变量i`,所以两次输出结果都是一样的，都是2。当前代码的关键点在于，变量i是全局的，函数执行时输出的都是全局作用域下的i值

![1](D:\web前端\ES6 note\img\1.png)

若把var改成let

```js
var arr = [];
for (let i = 0;i < 2;i++){
		arr[i] = function(){
			console.log(i);
	}
}
// 注意：for循环只是往arr数组中添加函数而不是执行
arr[0]();	//由于arr[i]的值就是函数所以可以直接后面加()调用
arr[1]();
```

由于使用let声明的变量，具有块级作用域，循环又执行两次。所以循环两次后产生了两个块级作用域，产生的两个块级作用域中都有自己的变量i，这是两个变量，是互不影响的，因为它们处于两个不同的块级作用域。循环结束后，数组中依然存储两个函数，函数执行时，函数内部依旧没有自己的变量i，还是要向上一级作用域中查找，而它们的上一级作用域实际上就是循环产生的块级作用域，所以两个函数执行时要分别去自己对应的块级作用域中查找变量i的值，所以数组中的第一个函数执行时，输出的是第一个块级作用域中变量i的值，就是0，第二个输出的是第二个块级作用域的值，就是1。

**关键点：**每一次循环都会产生一个块级作用域，每个块级作用域的变量i都是不同的。函数执行时，输出的是自己上一级作用域下变量i的值，也就是循环产生的块级作用域下i的值。

### const关键字