<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script>
			// const p = new Promise((resolve,reject)=>{
			// 	setTimeout(()=>{
			// 		//设置p对象的状态为失败，并设置失败的值
			// 		reject("error!");
			// 	},1000)
			// });

			// p.then(function(value){},function(reason){
			// 	console.error(reason);
			// });
			// p.catch(function(reason){
			// 	console.warn(reason);
			// })

			// let m = new Map();
			// m.set('name','zhang');
			// m.set('change',function(){
			// 	console.log('改变');
			// });
			// let key = {
			// 	school:'lu'
			// };
			// m.set(key,['beijing','shanghai']);
			// console.log(m);
			// function *gen(){
			//     yield'第一个';
			//     yield'第二个';
			//     yield'第三个';
			// }

			// let iterator = gen();
			// console.log(iterator.next());
			// console.log(iterator.next());
			// console.log(iterator.next());
			// console.log(iterator.next());
			// function *gen(arg){
			// 	console.log(arg);
			// 	let one = yield 111;
			//     console.log(one);
			// 	let two = yield 222;
			//     console.log(two);
			// 	let three = yield 333;
			//     console.log(three);
			// }

			// //执行获取迭代器对象
			// let iterator = gen('AAA');
			// //next方法可以传入实参
			// console.log(iterator.next());
			// console.log(iterator.next('BBB'));
			// //第二次next方法传入的参数将作为第一个yield语句整体返回结果
			// console.log(iterator.next('CCC'));
			// ////第三次next方法传入的参数将作为第二个yield语句整体返回结果
			// console.log(iterator.next('DDD'));
			// ////第四次next方法传入的参数将作为第三个yield语句整体返回结果

			// function getUsers(){
			// 	setTimeout(()=>{
			// 		let data = '用户数据';
			//         iterator.next(data);
			// 	},1000);
			// }
			// function getOrders(){
			// 	setTimeout(()=>{
			// 		let data = '订单数据';
			//          iterator.next(data);
			// 	},1000);
			// }
			// function getGoods(){
			// 	setTimeout(()=>{
			// 		let data = '商品数据';
			//         iterator.next(data);
			// 	},1000);
			// }
			// function *gen(){
			// 	let users = yield getUsers();
			//     console.log(users);
			//     let orders = yield getOrders();
			//     console.log(orders);
			//   	let goods = yield getGoods();
			//     console.log(goods)
			// }
			// //调用生成器函数
			// let iterator = gen();
			// iterator.next();

			//async 函数
			// async function fn(){
			// 	//返回一个字符串，一个数字，null，undefined等等，只要返回的结果不是一个promise类型的对象，则结果就是一个成功的promise对象
			// 	// return 'yes';
			// 	//抛出错误，返回的结果是一个失败的promise
			// 	// throw new Error('出错啦');
			// 	return new Promise((resolve,reject)=>{
			// 		resolve('成功的数据');
			// 		//reject('失败错误');	//调用resolve之后，这个对象就会变成一个成功的promise，一旦里面成功，fn返回的结果也是成功的
			// 		//且它成功的值就是函
			// 	});
			// }
			// const result = fn();
			// //调用then方法
			// result.then(value=>{
			// 	console.log(value);
			// },reason=>{
			// 	console.warn(reason);
			// })
			// async function fn2(){
			// 	//返回一个字符串，一个数字，null，undefined等等，只要返回的结果不是一个promise类型的对象，则结果就是一个成功的promise对象
			// 	// return 'yes';
			// 	//抛出错误，返回的结果是一个失败的promise
			// 	// throw new Error('出错啦');
			// 	return new Promise((resolve,reject)=>{
			// 		reject('失败错误');	//调用resolve之后，这个对象就会变成一个成功的promise，一旦里面成功，fn返回的结果也是成功的
			// 		//且它成功的值就是函
			// 	});
			// }
			// const result2 = fn2();
			// //调用then方法
			// result2.then(value=>{
			// 	console.log(value);
			// },reason=>{
			// 	console.warn(reason);
			// })

			//await要放在async函数中
			//注：await必须放在async中，但async函数中可以没有await

			// //创建promise对象
			// const p = new Promise((resolve,reject)=>{
			// 	// resolve("成功的值");
			// 	reject("失败啦");
			// })
			// //await返回的结果就是promise对象成功的值
			// async function main(){
			// 	try{
			// 		let result = await p;
			// 		console.log(result);
			// 	}catch(e){
			// 		//再catch里得到失败的结果并进行一些处理
			// 		console.log(e);	
			// 	}

			// }
			// main();

		</script>
	</body>
</html>
