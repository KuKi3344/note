### 继承

#### call方法

call()可以调用函数

```
function fn(x,y){
console.log("我想喝水");
console.log(this);
console.log(x+y);
}
var o ={
name :'andy'
};
//fn();
//1.call() 可以调用函数
//fn.call();
//2.call() 可以改变这个函数的this指向
//fn.call(o); 此时这个函数的this指向的是对象o
fn.call(o,1,2) //此时，1和2分别传入x和y，o是用来改变函数的this指向的，是不参与参数的传递的。
//可以写为fun.call(thisArg当前调用函数this的指向对象,arg1,arg2…传递的普通参数)
```

#### 借用父构造函数继承属性

```
//借用父构造函数继承属性
//父构造函数
function Father(uname,age){
//this指向父构造函数的对象实例
this.uname = uname;
this.age = age;
}
//子构造函数
function Son(uname,age){
	// this 指向子构造函数的对象实例，也就是指向Son
	Father.call(this,uname,age); 	// 让子构造函数去调用父构造函数
}
var son = new Son();
```

**备注**：目前发现的call()和super()的区别。都可以起到继承的作用（调用别的对象的方法，不同的是写法不同）super需要class Father ,在里面写构造函数，然后再class Son extends Father，然后再在Son里使用super调用父类函数

![Screenshot_20211103_190055_tv.danmaku.bili](D:\web前端\JavaScript note\js进阶\img\11.3\Screenshot_20211103_190055_tv.danmaku.bili.jpg)

如图（此图为面向对象文件笔记中的super关键字调用父类普通函数的图）

也就是说es5主要用这种构造函数继承的方法（使用call()），es6继承主要是class的继承

es5使用call或apply改变this指向，并执行了父类的构造函数,被称作**对象冒充继承**

![5](D:\web前端\JavaScript note\js进阶\img\11.7\5.png)

继承了Father的uname和age，同时也有自己的score属性，如图![6](D:\web前端\JavaScript note\js进阶\img\11.7\6.png)

#### 利用原型对象继承方法

公有方法可以写到原型对象上

![7](D:\web前端\JavaScript note\js进阶\img\11.7\7.png)

比如这个把共有方法money写到father的原型对象里

，在控制台打印后发现son里面没有money这个方法。

**原因：**money写到原型对象里而不是构造函数里，son调用的是father的构造函数而不是原型对象，所以找不到这个方法。

_**如果让子构造函数原型对象等于父构造函数原型对象呢？**_

给son的原型对象加一个私有的exam方法

![8](D:\web前端\JavaScript note\js进阶\img\11.7\8.png)

此时son里面出现了money方法和exam方法没有问题。但打印Father时，发现父亲也有exam，二者同步了，exam方法不是son私有的了。所以不能这样直接赋值，如果修改了子原型对象，父原型对象也会跟着一起变化

**正确方法：**

创建一个中间层![9](D:\web前端\JavaScript note\js进阶\img\11.7\9.png)

Son的原型对象等于实例化的父构造函数

但这样Son的原型对象的构造函数就指向Father了，所以需要利用constructor来指回原来的构造函数![10](D:\web前端\JavaScript note\js进阶\img\11.7\10.png)

这样就指回来了（指回Son）

**图解**

![11](D:\web前端\JavaScript note\js进阶\img\11.7\11.png)

#### ES6类的本质

类的本质其实还是一个函数，我们也可以简单的认为，类就是构造

