## 函数进阶

![3](D:\web前端\JavaScript note\js进阶\img\11.12\3.png)

#### 函数的定义和调用

```
//函数的定义方式
//1.自定义函数（命名函数）
function fn(){};
//2.函数表达式（匿名函数）
var fun = function(){};
//3. 利用new Function('参数1','参数2','函数体');
var f = new Function('a','b','console.log(a+b)');
f(1,2);
//但这种方法很少用，效率偏低
//但能通过这种方式得出一个结论：所有函数其实都是Function函数的一个实例对象，前面都是简写模式
//应了JS万物皆对象的说法
```

##### 函数的定义方式

![4](D:\web前端\JavaScript note\js进阶\img\11.12\4.png)

##### 函数的调用方式![5](D:\web前端\JavaScript note\js进阶\img\11.12\5.png)

```
//1.普通函数
function fn(){
	console.log('人生的巅峰');
}
fn();/fn.call()
//2.对象的方法
var o = {
sayHi:function(){
	console.log('人生的巅峰');
}
}
o.sayHi();
//3.构造函数
function Star(){};
new Star();
//4.绑定事件函数
btn.onclick = function(){}; // 点击了按钮就可以调用
//5.定时器函数
setInterval(function() {},1000);//这个函数是定时器自动一秒调用一次
//6.立即执行函数
(function(){
	console.log('人生的巅峰');
})();
//立即执行函数是自动调用
```

#### 函数内this的指向

**不同的调用方式决定了this的指向不同**

1.普通函数指向的是window

2.对象的方法this指向的是对象

3.构造函数指向的是实例对象，原型对象里面的this指向的也是实例对象

4.绑定事件函数的this指向的是函数的调用者（btn这个按钮对象）

5.定时器函数指向的对象还是window

6.立即执行函数指向的也是window，他和普通函数的区别就是不需要手动调用



![6](D:\web前端\JavaScript note\js进阶\img\11.12\6.png)

##### 改变this指向的方法

###### 1.call()

详情看继承笔记，之前已经学过

###### 2.apply()![1](D:\web前端\JavaScript note\js进阶\img\11.13\1.png)

和call的区别主要体现在参数不同

第一个参数是this指向，第二个参数必须是一个数组

```
function fn(){
console.log(1);
};
fn.apply(o);
// 也是调用函数
//但是它的参数必须是数组（伪数组）
fn.apply(o,['pink']); √
fn.apply(o,1); 		  × 会报错
```

apply的主要应用 ：比如我们可以利用apply借助于数学内置对象求最大值

// Math.max();

```
var arr =[1,66,3,99,4];
//Math.max.apply(null,arr); 指传递的this指向为空，不改变this指向
var max = Math.max.apply(Math,arr);	//严格模式用null可能有问题
var min = Math.min.apply(Math,arr);
console.log(max,min);
```

###### 3.bind()

传递的参数和call一样，不是数组

主要区别：只是改变this指向，生成新的函数，但不会自己调用

![2](D:\web前端\JavaScript note\js进阶\img\11.13\2.png)

```
var o = {
name:'andy'
};
function fn(a,b){
console.log(a+b);
};
fn.bind(o);
//它只是绑定但不会执行(调用)，可以改变原来函数内部的this指向，返回的是原函数改变this之后产生的新函数
var f = fn.bind(o,1,2); // 接收这个新函数
f();					//调用
```

```
//如果有的函数我们不需要立即调用但是又想改变这个函数内部的this指向，此时使用bind方法
//我们有一个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelector('button');
btn.onclick = function() {
this.disabled = true;
setTimeout(function(){
	this.disabled = false;	//定时器里面this指向的是window
}.bind(this),3000)		//这个this指向的是btn这个对象
}
```

```
//我们有多个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelectorAll('button');
for(var i=0;i<btn.length;i++){
	btn[i].onclick = function() {
	this.disabled = true;
	setTimeout(function(){
			this.disabled = false;	//定时器里面this指向的是window
		}.bind(this),3000)		//这个this指向的是btn这个对象
	}
}
//定时器是异步函数，for循环时立即执行。for循环嵌套定时器，btn[i]就不能当作this指向，因为i的数量不再对等。
```

