## js进阶

## 面向对象编程

### 创建对象



```javascript
class Star{
	constructor(uname,age){
	this.uname = uname;
	this.age = age;
	}
}
//利用类创建对象 new
var ldh = new Star('刘德华',18);
```



**注：**首字母要大写



`constructor函数`是构造函数，接受传过来的参数同时返回实例对象，并且只要new生成实例时，就会自动调用这个函数，不写也会自动生成



生成实例 new 不能省略



创建类时，类名后面不能加小括号，生成实例，类名后面加小括号，构造不需要加function。



#### **类中添加方法**



```javascript
class Star{
	constructor(uname,age){
	this.uname = uname;
	this.age = age;
	}
	sing(song){
	console.log(this.uname + song);
	}
}
	var ldh = new Star('刘德华',18);
	ldh.sing('冰雨');
```



类的共有属性放到constructor里面,利用类创建对象 new



类里的函数不需要写function,多个函数方法之间不需要加逗号分隔 (js类外的函数需要)



### **类的继承**



```javascript
class Father{
	constructor(x,y){
	this.x = x;
	this.y = y;
	}
	sum(){
	console.log(this.x + this.y);
	}
}
class Son extends Father{
	constructor(x,y){
	super();
	}
}
var son = new Son(1,2);
son.sum();
```



**注:**son继承了父亲的sum(),但是如果在son的构造函数中,如果不调用父类的构造函数而是写自己的构造函数,当new一个son的实例去调用继承的sum方法时就会报错,因为sum()方法里的x,y是father的,而son创建时构造的是自己的不是father的,所以若想使用父类的方法,就需要在构造函数中调用父类的构造函数.



#### **super关键字**



```javascript
class Father{
	say(){
	return '我是爸爸';
	}
}
class Son extends Father{
	say(){
		console.log(super.say() + '的儿子');
	}
}
var son = new Son();
son.say();
```



继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,有的话就近原则先执行子类的,如果子类里面没有,就去父亲那里找,如果有,就执行父亲的这个方法.



比如这个例子,直接通过super.say来调用父类的say方法.



#### **子类拓展私有方法**



```javascript
class Son extends Father{
	constructor(x,y){
	super(x,y);
	this.x = x;
	this.y = y;
	}
	subtract(){
	console.log(this.x + this.y);
	}
}
var son = new Son(5,3);
son.subtract();
son.sum();
```



子类继承父类的sum方法,同时私有subtract方法



利用super调用父类的构造函数,这样son就能使用父类的方法sum,再定义自己的构造函数，同时也写上自己的构造函数内容



**注:**super必须在子类this之前调用，即super()必须写再最前面



### **使用类的注意事项**



```javascript
class Star{
 	constructor(uname,age){
 		this.uname = uname;
 		this.age = age;
 		this.sing();
 	}
 	sing(){
 	console.log(this.uname);
 	}
}
var ldh = new Star('刘德华');
```



在es6中类没有变量提升,所以必须先定义类,才能通过类实例化对象,二者不能更换顺序



类里面的共有的属性和方法一定要加this使用



### 关于类里面this指向问题



哪个对象调用，this就指向谁。



```javascript
this.btn = document.querySelector('button');
this.btn.onclick = this.sing;
```



```javascript
sing(){
	console.log(this);
}
dance(){
	// 这个dance里面的this指向的是实例对象ldh，因为ldh调用了这个函数
	_that = this;
	console.log(this);
}
```



btn调用了sing，所以sing方法里面的this指向的是btn这个按钮



构造函数constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者



### 面向对象的练习



**功能：**



1.点击tab栏可以切换



2.点击+号，可以添加tab项和内容项



3.点击×号，可以删除当前的tab项和内容项



4.双击tab项文字或者内容项文字，可以修改里面的文字内容



**抽象对象：**Tab对象



该对象有切换，添加，删除，修改功能



**添加功能：**



第一步：创建新的选项卡li和新的内容section



第二步：把创建的两个元素追加到对应的父元素中



以前的做法：动态创建元素createElement，但是元素里面内容较多，需要innerHTML赋值再appendChild追加到父元素里面



现在的做法：利用insertAdjacentHTML()可以直接把字符串格式元素添加到父元素里面



**编辑功能：**



双击事件是：ondblclick



如果双击文字，会默认选定文字，此时需要双击禁止选中文字:



window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();



核心思路：双击文字的时候，在里面生成一个文本框，当失去焦点或者按下回车然后把文本框输入的值给原先的元素即可



js代码如下：



```javascript
var that;
class Tab{
	constructor(id) {
	    //获取元素
		that = this;
		this.main = document.querySelector(id);	
		this.add = this.main.querySelector('.tabadd');		//因为add按钮不会动态添加,所以不用放在updateNode里
		//获取li的父元素
		this.ul = this.main.querySelector('.firstnav ul:first-child');
		//section的父元素
		this.fsection = this.main.querySelector('.tabscon');
		this.init();
	}
	//init初始化操作,让相关元素绑定事件
	init(){
		this.updateNode();
		this.add.onclick = this.addTab;
		for(var i = 0;i<this.lis.length;i++){
			this.lis[i].index = i;
			this.lis[i].onclick = this.toggleTab; //函数加小括号和不加的区别:不加点击才调用,加了后页面加载就调用
				// 调用toggleTab的是li,所以toggleTab里的this指向的是li
			this.remove[i].onclick = this.removeTab;
			this.spans[i].ondblclick = this.editTab;
			this.sections[i].ondblclick = this.editTab;
		}
	}
	//获取所有的li和section 因为这两个随时可能更新,因为我们动态添加元素需要重新获取对应的元素
	updateNode(){
		this.lis = this.main.querySelectorAll('li');
		this.sections = this.main.querySelectorAll('section');
		this.remove = this.main.querySelectorAll('.icon-guanbi');
		this.spans = this.main.querySelectorAll('.firstnav li span:first-child');
	}
	// 1.切换功能
	toggleTab(){
		// console.log(this.index);
		that.clearClass();	//利用构造函数里的this调用这个方法才能li和sections都作用到
		this.className = 'liactive';	//this指向的是lis而非构造函数里的this,所以需要用全局变量that
		that.sections[this.index].className = 'conactive';	// conactive绑定的样式为下边框消失
	}
	// 清除li和section名字的函数
	clearClass(){
		for(var i = 0;i<this.lis.length;i++){
			this.lis[i].className = '';
			this.sections[i].className = '';
		}
	}
	
	//添加功能
	addTab(){
		that.clearClass();
		var random = Math.random();
		//创建li元素和section元素
		var li = '<li class = "liactive"><span>新选项卡</span><span class = "iconfont icon-guanbi">×</span></li>';	
		var section = '<section class = "conactive">新内容'+random+'</section>';
		//把两个元素追加到对应的父元素里面
		that.ul.insertAdjacentHTML('beforeend',li); //把li字符串追加到父元素里面,在最后面追加
		that.fsection.insertAdjacentHTML('beforeend',section); //把li字符串追加到父元素里面,在最后面追加
		that.init();	// 识别新加的li和section并让相关元素绑定事件
	}
	//删除功能
	removeTab(e){	//e是事件对象 e是event的意思，每一个元素都有的，只是一般没显示出来
		e.stopPropagation();	//阻止冒泡 ,防止触发li的切换点击事件
		var index = this.parentNode.index;
		console.log(index);
		that.lis[index].remove();
		that.sections[index].remove();
		that.init();	//因为数量发生变化所以需要重新获取元素
		// 当我们删除的不是选中状态的li时,让之前选中的li保持选中不变
		if (document.querySelector('.liactive')) return;
		// 当我们删除选中状态的这个li时,让它的前一个li处于选定状态
		index--;
		//手动调用点击事件,不需要鼠标触发
		//若删除了剩的最后一个,由于that.lis[index]为false,所以不处罚点击事件
		that.lis[index] && that.lis[index].click();
		
	}
	//修改功能
	editTab(){
		//将原来的文字赋值给str
		var str = this.innerHTML;
		//双击禁止选定文字
		window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();
		//生成一个文本框
		this.innerHTML = '<input type="text"/>';
		var input = this.children[0];
		input.value = str;	//将之前里面的文字拿到文本框里
		input.select();     //让文本框里的文字处于选中状态
		input.onblur = function(){
			this.parentNode.innerHTML = this.value;
			// input里面的内容将input取代了所以input消失了，比如生成文本框后<span><input>xxx</span>
			//this在上面指向的是span，span的第一个孩子是input，input的父节点是span
			//所以span里的东西变成了input里的值（input调用的函数所以onblur绑定的函数里的this指向的是input）
		};
		//按下回车也可以把文本框里面的值给span
		input.onkeyup = function(e){
			if (e.keyCode === 13){
				//手动调用表单失去焦点事件，不需要鼠标离开操作
				this.blur();	//这里this指向的是input,因此也能调用onblur方法
			}
		}
	}
}
var tab = new Tab('#tab');
```



**注：**等之后学到bind()，就不用在开始定义一个全局变量that，可以直接用bind来实现，具体看函数进阶笔记的改变this指向的办法3-bind()



## 构造函数和原型



在面向对象的语言中，都存在类的概念。类就是对象的模板，对象就是类的实例。但是在ES6之前，JS没有引入类的概念，且对象不是基于类创建的，二十用一种成为构造函数的特殊函数来定义对象和它们的特征。



### 创建对象



创建对象可以通过以下三种方式



**1.对象字面量**



```javascript
var objectName = {
    属性名1 : 属性值1,
    属性名2 : 属性值2,
    ...
    属性名n : 属性值n
};
```



**2.new Object()**



```javascript
var obj  = new Object();  //Object为系统的构造函数 
obj.name="小明";  //添加属性  ————对象名.名字=值;
obj.eat=function(){   //添加方法  ————对象名.名字=函数;
        console.log("做饭");
    };
console.log(obj.name); //调用属性
obj.eat(); //调用方法
```



**3.自定义构造函数**



```javascript
function Star(uname,age){
	this.uname = uname;
	this.age = age;
	this.sing = function(){
		console.log('我会唱歌');
	}
}
var ldh = new Star('刘德华',18);
console.log(ldh);
ldh.sing();
```



**实例成员**就是构造函数内部通过this添加的成员 uname age sing 就是实例成员



实例成员(构造函数内部成员)只能通过实例化的对象来访问



```javascript
console.log(ldh.uname);√
ldh.sing();
//console.log(Star.uname)×  不可以通过构造函数来访问实例成员
//静态成员 在构造函数本身上添加的成员 sex就是静态成员
Star.sex = '男';
// 静态成员只能通过构造函数来访问
console.log(Star.sex); √
//console.log(ldh.sex);× 静态成员不能通过对象来访问
```



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811353931-61a0e51b-4cf2-4027-b8d6-bf818b0c85c6.png)



构造函数方法很好用，但是存在`**浪费内存的问题**`



每创建一个对象就要分配一个内存，开辟的内存空间是不一样的，它们存的地址是不一样的。所以就需要构造函数原型prototype来解决这个问题。



### 构造函数原型 prototype



构造函数通过原型分配的函数时所有对象所共享的



JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，**注：**这个prototype就是一个对象。这个对象的所有属性和方法，都会被构造函数所拥有。（它不会再开辟新的内存空间）



**我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法**



```javascript
Star.prototype.sing = function(){
	console.log('我会唱歌');
}
var ldh = new Star('刘德华',18);
var zxy = new Star('张学友',19);
ldh.sing();
zxy.sing();
```



**一般情况下，我们的公共属性定义到构造函数里面，公共方法我们放到原型对象身上**



### 对象原型`__proto__`



```javascript
//在对象身上系统给自己添加一个__proto__ 指向我们构造函数的原型对象
console.log(ldh.__proto__ ===Star.prototype);
//true
//证明__proto__指向了构造函数的原型对象，二者等价
//方法的查找规则：首先先看ldh，对象身上是否有sing方法，如果有就执行这个对象上的sing，如果没有sing这个方法，因为有__proto__的存在，就去构造函数原型对象prototype身上去查找
```



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811377110-6f1c17a7-fc5c-41e1-8c7f-95da52308ad8.png)



对象原型( **proto** )和构造函数原型对象（prototype）里面都有一个构造函数constructor，指向的都是**最开始定义的构造函数**本身



constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数



**很多情况下，我们需要手动的利用constructor这个属性指回原来的构造函数**



```javascript
//第一种
Star.prototype.sing = function(){
	console.log('我会唱歌');
};
Star.prototype.movie = function(){
	console.log('我会拍电影');
};
//第二种
Star.prototype = {
	sing:function(){
		console.log('我会唱歌');
	},
	movie:function(){
		console.log('我会拍电影');
	}
}
```



把原型对象合并写成上面的第二种写法后，就不指回原来的构造函数了。



**原因是：**上面的第一种写法，是在对象中添加这个方法，而下面的是让原型对象等于了一个对象，相当于用后面的对象把原先的Star.prototype里面这个对象全都覆盖了，覆盖之后，Star.prototype里面就没有constructor这个属性了，也就是说把原来Star.prototype里面的constructor属性被覆盖掉了,没有constructor就没有办法指回原来的构造函数了。所以需要手动的利用constructor这个属性指回原来的构造函数。

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811418864-e103d9fd-76cd-4938-a715-c68acfbb629e.png)





*通过打印发现里面没有constructor这个属性*



**手动添加：**



```javascript
Star.prototype = {
constructor:Star,
sing:function(){
console.log('sing');
},
movie:function(){
console.log('movue');
}
}
```



添加后又指回了原来的构造函数了



### 原型链详解图



![img](https://cdn.nlark.com/yuque/0/2021/webp/23070022/1636811219496-cc83d979-3c03-417b-81c9-994bcc9e2126.webp)



#### JS成员查找机制



1.当访问一个对象的属性（包括方法）时，首先查找**这个对象自身**有没有该属性



2.如果没有就查找他的原型（也就是`__proto__`指向的**prototype原型对象**）



3.如果还没有就查找原型对象的原型（**Object的原型对象**）



4.依次类推一直到找到Object为止（**null**）



```javascript
function Star(uname,age){
	this.uname = uname;
	this.age = age;
}
Star.prototype.sing = function() {
	console.log('我会唱歌');
}
// Star.prototype.sex = '女';
//Object.prototype.sex = '男';
var ldh = new Star('刘德华',18);
//ldh.sex = '男';
console.log(ldh.sex);
```



如果都注释掉，就找不到sex这个成员了，控制台输出为`undefined`



原型对象函数里面的this 指向的也是实例对象 ldh，也是谁调用就指向谁



#### 扩展内置对象



给数组的原型对象加一个sum方法



```javascript
Array.prototype.sum = function(){
	var sum = 0;
	for (var i = 0;i<this.length;i++){
		sum += this[i];
	}
	return sum;
}
var arr = [1,2,3];
console.log(arr.sum());
console.log(Array.prototype);
```



打印结果

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811445362-abb7a56f-bae6-48d0-a430-bf92472f73c4.png)





**注：**数组和字符串的内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式，不然会把原来里面的其它内置函数也覆盖导致消失。（和自己定义的对象的原型对象覆盖操作只需要添加构造函数指回去不同，它指回去也不行）



## 继承



### call方法



call()可以调用函数



它的主要作用是实现继承



```javascript
function fn(x,y){
console.log("我想喝水");
console.log(this);
console.log(x+y);
}
var o ={
name :'andy'
};
//fn();
//1.call() 可以调用函数
//fn.call();
//2.call() 可以改变这个函数的this指向
//fn.call(o); 此时这个函数的this指向的是对象o
fn.call(o,1,2) //此时，1和2分别传入x和y，o是用来改变函数的this指向的，是不参与参数的传递的。
//可以写为fun.call(thisArg当前调用函数this的指向对象,arg1,arg2…传递的普通参数)
```



### 借用父构造函数继承属性



```javascript
//借用父构造函数继承属性
//父构造函数
function Father(uname,age){
//this指向父构造函数的对象实例
this.uname = uname;
this.age = age;
}
//子构造函数
function Son(uname,age){
	// this 指向子构造函数的对象实例，也就是指向Son
	Father.call(this,uname,age); 	// 让子构造函数去调用父构造函数
}
var son = new Son();
```



**备注**：目前发现的call()和super()的区别。都可以起到继承的作用（调用别的对象的方法，不同的是写法不同）super需要class Father ,在里面写构造函数，然后再class Son extends Father，然后再在Son里使用super调用父类函数



```javascript
class Father{
	say(){
	return '我是爸爸';
	}
}
class Son extends Father{
	say(){
		console.log(super.say() + '的儿子');
	}
}
var son = new Son();
son.say();
```



如上（以上为面向对象文件笔记中的super关键字调用父类普通函数的代码）



**也就是说es5主要用这种构造函数继承的方法（使用call()），es6继承主要是class的继承** （以上备注为个人观点）



es5使用call或apply改变this指向（之后函数进阶会讲到），并执行了父类的构造函数,被称作**对象冒充继承**



```javascript
function Father(uname,age){
	//this指向父构造函数的对象实例
	this.uname = uname;
	this.age = age;
}
//2.子构造函数
function Son(uname,age,score){
	//this 指向子构造函数的对象实例
	Father.call(this,uname,age);
	this.score = score;
}
var son = new Son('儿子',18,100);
console.log(son);
```



继承了Father的uname和age，同时也有自己的score属性，如图



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811489870-1765662c-87b1-4813-b1ab-25211ca4006c.png)

### 利用原型对象继承



公有方法可以写到原型对象上



```javascript
function Father(uname,age){
	//this指向父构造函数的对象实例
	this.uname = uname;
	this.age = age;
}
Father.prototype.money = function(){
	console.log(10000);
}
//2.子构造函数
function Son(uname,age,score){
	//this 指向子构造函数的对象实例
	Father.call(this,uname,age);
	this.score = score;
}
var son = new Son('儿子',18,100);
console.log(son);
```



比如这个把共有方法money写到father的原型对象里，在控制台打印后发现son里面没有money这个方法。



**原因：**money写到原型对象里而不是构造函数里，son调用的是father的构造函数而不是原型对象，所以找不到这个方法。



***如果让子构造函数原型对象等于父构造函数原型对象呢？\***



给son的原型对象加一个私有的exam方法



```javascript
function Son(uname,age,score){
	Father.call(this,uname,age);
	this.score = score;
	}
Son.prototype = Father.prototype;
//这个是子构造函数专门的方法
Son.prototype.exam = function(){
	console.log('孩子考试');
}
```



此时son里面出现了money方法和exam方法没有问题。但打印Father时，发现父亲也有exam，二者同步了，exam方法不是son私有的了。所以不能这样直接赋值，如果修改了子原型对象，父原型对象也会跟着一起变化



**正确方法：**



创建一个中间层



```javascript
Son.prototype = new Father();
//这个是子构造函数专门的方法
Son.prototype.exam = function(){
	console.log('孩子考试');
}
var son = new Son('刘德华',18,100);
console.log(son);
console.log(Father.prototype);
console.log(Son.prototype.constructor);
```



Son的原型对象等于实例化的父构造函数



但这样Son的原型对象的构造函数就指向Father了，所以需要利用constructor来指回原来的构造函数



```javascript
//Son.prototype = Father.prototype;	这样直接赋值会有问题，修改子原型对象，父原型对象也会跟着一起变化
Son.prototype = new Father();
//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数
Son.prototype.constructor = Son;
```



这样就指回来了（指回Son）



**图解**



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811527634-5cdb9781-1cdd-4766-949a-b6ed86582cb6.png)



### ES6类的本质



1.class本质还是function



2.类的所有方法都定义在类的prototype属性上



3.类创建的实例，里面也有`__proto__`指向类的prototype原型对象



4.所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已



5.所以ES6的类其实就是语法糖



6.语法糖：语法糖就是一种便捷写法，简单理解，有两种方法可以实现同样的功能，但是一种写法更加清晰方便，那么这个方法就是语法糖



**类的本质其实还是一个函数，我们也可以简单的认为，类就是构造函数的另外一种写法**



**ES6之前通过 构造函数+原型实现面向对象编程**



1.构造函数有原型对象prototype



2.构造函数原型对象prototype 里面有constructor指向构造函数本身



3.构造函数可以通过原型对象添加方法



4.构造函数创建的实例对象有`__proto__`原型指向构造函数的原型对象



ES6 通过类实现面向对象编程



```javascript
class Star{

}
console.log(typeof Star);
console.log(Star.prototype);
```



## ES5中的新增方法



### 数组方法



迭代遍历方法：forEach(),map(),some(),every();



#### **forEach()**



```javascript
array.forEach(function(currentValue,index,arr))
```



-  currentValue :数组当前项的值 
-  index : 数组当前项的索引 

-  arr : 数组对象本身  

```javascript
var forEach(function(value,index,array){
console.log('每个数组元素'+value);
console.log('每个数组元素的索引号'+index);
console.log('数组本身'+array);
sum += value;
})
console.log(sum);
```



#### filter()



filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组



**注：**它直接返回一个新数组



```javascript
array.filter(function(currentValue,index,arr))
```



currentValue:数组当前项值



index：数组当前项的索引



arr：数组对象本身



```javascript
var arr = [12,64,4,88];
var newArr = arr.filter(function(value,index){
return value >= 20;
});
console.log(newArr);
```



#### some()



```javascript
array.some(function(currentValue,index,arr))
```



-  some()方法用于检测数组种的元素是否满足指定条件。通俗来说就是查找数组中是否有满足条件的元素 
-  注:它的返回值是布尔值，如果查找到这个元素，就返回true，查找不到就返回false 

-  如果找到第一个满足条件的元素，则终止循环，不再继续查找 
-  currentValue：数组当前项的值 

-  index：数组当前项的索引 
-  arr：数组对象本身  

```javascript
var arr = [10,30,4];
var flag = arr.some(function(value){
	return value < 3;
})
console.log(flag);

var arr1 = ['red','pink','blue'];
var flag1 = arr1.some(function(value){
	return value == 'pink';
})
console.log(flag1);
```



##### some()和forEach(),filter()的区别



在forEach()里面遇到return不会终止，但some不一样，some遇到return会终止遍历迭代，效率更高



在some里return true会停止迭代。必须return true，说明找到了这个元素，然后迭代才终止。



**filter**和forEach一样遇到retuen也不会终止迭代



所以在查找唯一元素的时候应该用some，效率更高，是最好的选择



### 字符串方法



#### trim()



```javascript
//trim 方法去除字符串两侧空格
var str = '		andy	';
console.log(str);
var str1 = str.trim();	//获得去除左右两侧空格的新字符串，但不会去除字符之间的空格
console.log(str1);
```



```javascript
<input type = "text"> <button>点击</button>
<div></div>
<script>
var input = document.querySelector('input');
var btn = document.querySelector('button');
var div = document.querySelector('div');
btn.onclick = function(){
if (input.value === ''){
	alert('请输入内容')
}else{
console.log(input.value);
console.log(input.value.length);
div.innerHTML = input.value;
}
}
</script>
```



按上面这段代码来写，当输入一个空格时，由于判断值时里面有一个空格所以判断不为空不会出现提示。并且当输入的内容携带空格时，也不能识别出把空格去掉，因此就需要trim()函数,所以需要改成以下这样



```javascript
var str = input.value.trim();
if (str === ''){
	alert('请输入内容')
}else{
console.log(str);
console.log(str.length);
div.innerHTML = str;
}
```



### Object对象方法



##### Object.keys()



遍历方法，可以遍历属性



##### Object.defineProperty()



定义对象中新属性或修改原有的属性



```javascript
Object.defineProperty(obj,prop,descriptor)
```



- obj:必需。目标对象
- prop：必须。需定义或者修改的属性的名字

- descriptor：必需。目标属性所拥有的特性



Object.defineProperty(）第三个参数descriptor说明：以对象形式{}书写



- value:设置属性的值，默认为undefined
- writable:值是否可以重写。true|false，默认为false

- enumerable:目标属性是否可以被枚举.true|false 默认为false
- configurable:目标属性是否可以被删除或者是否可以再次修改特性true|false 默认为false



```javascript
var obj = {
id:1,
pname:'小米',
price:1999
};
//1.以前的对象添加和修改属性的方式
//obj.num = 1000;
//obj.price = 99;
//console.log(obj);
//2.Object.defineProperty()
Object.defineProperty(obj,'num',{
	value:1000
});
Object.defineProperty(obj,'price',{
	value:9.9
});
//没有这个属性的话就添加，如果有了这个属性就修改原有属性，修改成新定义的值
Object.defineProperty(obj,'id',{
	//不允许修改这个属性值
	writable:false,
});
obj.id = 2;
//尝试修改id看是否能修改
console.log(obj);
//结果id没变还是1
//但如果writable改成true就能修改，writable默认值为false
Object.defineProperty(obj,'address',{
	value:'大连xx小区',
	enumerable:false,
	// enumerable 如果值为false，则不允许遍历，不在方法里写这个属性的话默认的值为false
	configurable:false
	//configurable 如果为false，则不允许删除这个属性，也不允许修改这个属性第三个参数里面的特性（如改成可修改或可遍历），默认值为false.
});
console.log(Object.keys(obj));
delete obj.address;
//原先定义的pname是没有这些属性的，所以可删除可重写，课可遍历
```



## 函数进阶



### 函数的定义和调用



```javascript
//函数的定义方式
//1.自定义函数（命名函数）
function fn(){};
//2.函数表达式（匿名函数）
var fun = function(){};
//3. 利用new Function('参数1','参数2','函数体');
var f = new Function('a','b','console.log(a+b)');
f(1,2);
//但这种方法很少用，效率偏低
//但能通过这种方式得出一个结论：所有函数其实都是Function函数的一个实例对象，前面都是简写模式
//应了JS万物皆对象的说法
```



#### 函数的定义方式



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811622802-62662ee5-c0ca-45c5-a752-4ea45ea976e2.png)

#### 



```javascript
//1.普通函数
function fn(){
	console.log('人生的巅峰');
}
fn();/fn.call()
//2.对象的方法
var o = {
sayHi:function(){
	console.log('人生的巅峰');
}
}
o.sayHi();
//3.构造函数
function Star(){};
new Star();
//4.绑定事件函数
btn.onclick = function(){}; // 点击了按钮就可以调用
//5.定时器函数
setInterval(function() {},1000);//这个函数是定时器自动一秒调用一次
//6.立即执行函数
(function(){
	console.log('人生的巅峰');
})();
//立即执行函数是自动调用
```



### 函数内this的指向



**不同的调用方式决定了this的指向不同**



1.普通函数指向的是window



2.对象的方法this指向的是对象



3.构造函数指向的是实例对象，原型对象里面的this指向的也是实例对象



4.绑定事件函数的this指向的是函数的调用者（btn这个按钮对象）



5.定时器函数指向的对象还是window



6.立即执行函数指向的也是window，他和普通函数的区别就是不需要手动调用



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811684043-27491b8d-5736-4254-bbd7-43f314f6ffdd.png)



#### 改变this指向的方法



##### 1.call()



详情看继承笔记，之前已经学过



##### 2.apply()

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811717293-b74513b8-0cf6-4702-aa66-9d753d6f6933.png)



和call的区别主要体现在参数不同



第一个参数是this指向，第二个参数必须是一个数组



```javascript
function fn(){
console.log(1);
};
fn.apply(o);
// 也是调用函数
//但是它的参数必须是数组（伪数组）
fn.apply(o,['pink']); √
fn.apply(o,1); 		  × 会报错
```



apply的主要应用 ：比如我们可以利用apply借助于数学内置对象求最大值



// Math.max();



```javascript
var arr =[1,66,3,99,4];
//Math.max.apply(null,arr); 指传递的this指向为空，不改变this指向
var max = Math.max.apply(Math,arr);	//严格模式用null可能有问题
var min = Math.min.apply(Math,arr);
console.log(max,min);
```



##### 3.bind()



传递的参数和call一样，不是数组



主要区别：只是改变this指向，生成新的函数，但不会自己调用



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811767740-377d7973-160e-4abb-83f0-4b20b0521454.png)



```javascript
var o = {
name:'andy'
};
function fn(a,b){
console.log(a+b);
};
fn.bind(o);
//它只是绑定但不会执行(调用)，可以改变原来函数内部的this指向，返回的是原函数改变this之后产生的新函数
var f = fn.bind(o,1,2); // 接收这个新函数
f();					//调用
```



如果有的函数我们不需要立即调用但是又想改变这个函数内部的this指向，此时使用bind方法



```javascript
//如果有的函数我们不需要立即调用但是又想改变这个函数内部的this指向，此时使用bind方法
//我们有一个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelector('button');
btn.onclick = function() {
this.disabled = true;
setTimeout(function(){
	this.disabled = false;	//定时器里面this指向的是window
}.bind(this),3000)		//这个this指向的是btn这个对象
}
```



```javascript
//我们有多个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelectorAll('button');
for(var i=0;i<btn.length;i++){
	btn[i].onclick = function() {
	this.disabled = true;
	setTimeout(function(){
			this.disabled = false;	//定时器里面this指向的是window
		}.bind(this),3000)		//这个this指向的是btn这个对象，这样就将定时器从window绑定到了btn这个对象上
	}
}
//定时器是异步函数，for循环时立即执行。for循环嵌套定时器，btn[i]就不能当作this指向，因为i的数量不再对等。
```



**bind应用面向对象tab栏**



代码见面向对象笔记



如在切换tab里，toggleTab函数里既需要构造函数里的this有需要构造函数里的this.lis[i]，所以可以用bind



```javascript
this.lis[i].onclick = this.toggleTab.bind(this.lis[i],this);

toggleTab(that) // 把上面绑定的this值传入名为that，但这个函数指向的依旧是this.lis[i]
//其它方法同理
```



这么写省的定义全局变量that了，可以避免像之前那样全局变量that的使用



##### **总结**



call apply bind 总结



**相同点：**都可以改变函数内部的this指向



**区别点：**1.call和apply都会调用函数并且改变函数内部this指向



​			  2.call和apply传递的参数不一样，call传递参数aru1，aru2形式，apply必须数组形式[arg]



​			  3.bind不会调用函数，可以改变函数内部this指向



**主要应用场景：**



1.call经常做继承



2.apply经常和数组有关系，比如借助数学对象实现数组最大值最小值



2.bind 不调用函数，但是能改变this指向，比如改变定时器内部的this指向



### 严格模式



JS除了提供正常模式外，还提供了**严格模式**。ES5的严格模式是采用具有限制性JS变体的一种方式，即在严格的条件下运行JS代码



严格模式在IE 10以上版本的浏览器中才会被支持，旧版浏览器中会被忽略



严格模式对正常的JS语义做了一些更改



1.消除了JS语法的一些不合理，不严谨，减少了一些怪异行为



2.消除代码运行的一些不安全之处，保证代码运行的安全



3.提高编译器效率，增加运行速度



4.禁用了在ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的JS做好铺垫，比如一些保留字如：class，enum，export，extends，import，super不能做变量名



##### 开启严格模式



严格模式可以应用到整个脚本或者个别函数中，因此使用时，我们可以将严格模式分为**为脚本开启严格模式**和**为函数开启严格模式**两种情况



为整个脚本开启严格模式，需要在所有语句之前放一个特定语句‘use strict’;



```javascript
<script>
'use strict';
// 下面写的所有的代码就会按照严格模式来执行
</script>
```



或者写在立即执行函数里，也可以起到为整个脚本开启严格模式的作用



```javascript
<script>
(function(){
	'use strict';
})();

</script>
```



只给一个函数开启严格模式



```javascript
function fn(){
'use strict';
//下面的代码按照严格模式执行
}
function fun(){
//里面的还是按照普通模式执行
}
```



##### 严格模式中的变化



1.以前一个变量可以不声明直接赋值使用，严格模式必须先声明再使用



2.不能在严格模式下随意删除已经声明好的变量



**严格模式下this指向问题**



以前在全局作用域函数中的this指向window对象，严格模式下全局作用域中的this是undefined



以前构造函数时不加new也可以调用，当普通函数，this指向全局对象。严格模式下，如果构造函数不加new调用，this会报错



new实例化的构造函数指向创建的对象实例



定时器this还是指向window



事件，对象还是指向调用者



##### 函数变化



函数里不能有重名的参数



函数必须声明在顶层，JS会引入“块级作用域”。为了与新版本接轨，不允许在非函数的代码块内声明函数



例子:



```javascript
if(true){
	functioon f(){}
	f();
}
for(var i=0;i<5;i++){
	function f2(){}
	f2();
}
function baz(){
function ait(){}
}
```



前两种不行，会报语法错误



最后一种在严格模式下可行



### 高阶函数



高阶函数是对其它函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出



```javascript
function fn(callback){
	callback&&callback();	//相当于先判断是否有callback有则执行
}
fn(function(){alert('hi')});
```



```javascript
function fn(){
	return function(){}
}
fn();
```



此时fn就是一个高阶函数



函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用，最典型的就是作为回调函数



### 闭包



##### 变量作用域



变量根据作用域的不同分为两种：全局变量和局部变量



1.函数内部可以使用全局变量



2.函数外部不可以使用局部变量



3.当函数执行完毕，本作用域内的局部变量会销毁



##### **什么是闭包**



**闭包**指有权访问另一个函数作用域中变量的函数



简单理解就是，一个作用域可以访问另外一个函数内部的局部变量



```javascript
function fn(){
	var num = 10;
	function fun(){
	console.log(num);
	}
	fun();
}
fn();
// fun这个函数作用域，访问了另外一个函数fn里面的局部变量num
//这里的fun()是闭包
```



```javascript
//fn外面的作用域可以访问fn内部的局部变量
function fn(){
	var num = 10;
	function func(){
		console.log(num);
	}
	return fun;
}
var f = fn();
f();
//类似于
//var f = function fun(){
//	console.log(num);
//}
```



也可以写成以下这种写法比较简便



```javascript
function fn(){
var num = 10;
return function(){
	console.log(num);
}
//只要返回的是函数就是属于高阶函数
//所以返回这个函数也是闭包的主要实验思路
//闭包是典型的高阶函数
}
var f = fn();
f();
```



##### 闭包的主要作用



延伸了变量的作用范围



闭包可以用在许多地方。它的最大用处有两个，一个是**可以读取函数内部的变量**，另一个就是**让这些变量的值始终保持在内存中**，不会在调用后被自动清除。



由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。**解决方法是，在退出函数之前，将不使用的局部变量全部删除。**



##### 闭包案例



**案例一：**点击输出当前li索引号



```javascript
<ul class="nav">
			<li>榴莲</li>
			<li>臭豆腐</li>
			<li>鲱鱼罐头</li>
			<li>猪蹄</li>
		</ul>
```



```javascript
		//闭包应用 - 点击li输出当前li的索引号
		//1.我们可以利用动态添加属性的方式
		var lis = document.querySelector('.nav').querySelectorAll('li');
		for (var i=0;i<lis.length;i++){
			lis[i].index = i;
			lis[i].onclick = function(){
				console.log(this.index);
			}
		}
		//2.利用闭包的方式得到当前li的索引号（据说是面试重点！）
		for(var i = 0;i<lis.length;i++){
			//利用for循环创建了四个立即执行函数
			//立即执行函数里面的任何一个函数都可以使用它的i变量
			(function(i){	//这个i是通过下面的i传过来的，每循环一次传递的i不一样
					lis[i].onclick = function(){
						console.log(i);
					}
			})(i);	
		}
		</script>
```



**案例二**：三秒后打印所有li元素的内容



```javascript
//闭包应用2：3秒后打印所有li元素内容
			var lis = document.querySelector('.nav').querySelectorAll('li');
			for (var i = 0; i < lis.length; i++) {
				//for循环是同步任务
				// 像点击，悬浮触发函数都是异步的，所以需要立即执行函数，否则会出现问题
				(function(i) {
					setTimeout(function() {
						console.log(lis[i].innerHTML);
					}, 3000)
				})(i);
			}
```



**案例三**：计算打车价格



```javascript
	//闭包应用三：计算打车价格
			//打车起步价13（3公里内），之后每多一公里增加五元，用户输入公里数就可以计算打车价格
			//如果有拥堵情况，总价格多收取十块钱拥堵费
			var car = (function(){
				var start = 13;	// 起步价
				var total = 0;	//总价
				return {
					//正常总价
					price:function(n){
						if (n<=3){
							total = start;
						}else{
							total = start + (n - 3) * 5;
						}
						return total;
					},
					//拥堵之后的费用		
					yd:function(flag){
						return flag ? total + 10 : total;
						// 如果flag为true则total加10否则total不变
					}			
				}
			})();
			console.log(car.price(5));	//因为闭包把值存储在里面了 并没有销毁，所以这里23不会被销毁，所以下面会输出33
			console.log(car.yd(true));
```

### 递归

如果一个函数在内部可以调用其本身，那么这个函数就是递归函数

简单理解：函数内部自己调用自己，这个函数就是递归函数

```javascript
var num = 1;
function fn(){		//无限套娃
	console.log('我要打印6句话');
    if(num == 6){
		return;		//递归里面必须添加退出条件，否则会变成死递归
    }
    num++;
    fn();
}
fn();
```

递归函数的作用和循环效果一样

由于递归很容易发生栈溢出错误，所以必须要加退出条件return

（目前貌似有公司禁止使用）

##### 递归案例

利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 *...n

```
function fn(n){
if (n == 1){
	return 1;
	}
	return n * fn(n-1);
}
console.log(fn(3));
```

2.利用递归函数求斐波那契数列（兔子序列）1, 1 , 2, 3 , 5, 8 ,13 ,21 ...

用户输入一个数子n就可以求出这个数字对应的兔子序列值

我们只需要知道用户输入的n 的前面两项就可以计算出n对应的值

```
function fb(n){
	if (n === 1||n === 2){
		return 1;
	}
	return fb(n-1)+ fb(n-2);
}
console.log(fb(3));
```

3.利用递归遍历数据

```JavaScript
var data = [{
			id:1,
			name:'家电',
			goods:[{
				id:11,
				gname:'冰箱',
				goods:[
					{
					id:111,
					gname:'海尔'
				},
				{
					id:112,
					gname:'美的'
				},					
				]
			},
			{
				id:12,
				gname:'洗衣机'
			}]
			},
			{
				id:2,
				name:'服饰'
			}
		];
		// 我们想要做输入id号，就可以返回的数据对象
		//1.利用 foreach 去遍历里面的每一个对象
		function getID(json,id){
			json.forEach(function(item){
				if (item.id == id){
					console.log(item);
					o = item;
					//我们想要得到里层的数据 11 12可以利用递归函数
					//里面应该有goods这个数组，并且数组的长度不为0
				}else if(item.goods && item.goods.length>0){
					o = getID(item.goods,id);
				}
			
			});
			return o;
		}
		getID(data,1);
		getID(data,112);
```

#### 浅拷贝和深拷贝

##### 浅拷贝

浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用

```javascript
	var obj = {
			id: 1,
			name: 'andy',
			msg:{
				age: 18
			}
		};
		var o ={};
		for(var k in obj){
			//k是属性名，obj[k]是属性值
			o[k] = obj[k];	//相当于o.k
			
		}
		console.log(o);
		o.msg.age = 20;//测试更改o的msg会不会影响obj的
		console.log(obj);
//结果：o和obj的age都是20
```

这就是浅拷贝。但这样拷贝，msg属于深层次对象级别，虽然能拷贝过来，但是拷贝的是地址，也就是o的msg和obj的msg指向的是同一个数据，此时若修改o的msg也会影响obj里面的msg，如上面测试结果。但是如果更改最外层的数据（例如name），修改o不会影响obj

![1](D:\web前端\JavaScript note\js进阶\img\11.15\1.png)



Object.assign(target,...sources) 是es6新增方法可以实现浅拷贝（语法糖）

target:接受的对象

sources：被拷贝对象

也就是把sources拷贝给target

```javascript
Object.assign(o,obj);
console.log(o);
// 此段代码和上面代码的for循环起到了相同作用
```

##### 深拷贝

深拷贝拷贝多层，每一级别的数据都会拷贝。在这里obj中的msg又是一个对象，所以会新开辟一个空间，深拷贝会把新开辟的空间重新复制一份新的空间，把拷贝完的空间再给o，这样两个空间互不相干，故而改变其中一个不会影响另外一个

![2](D:\web前端\JavaScript note\js进阶\img\11.15\2.png)

**代码案例：**

```javascript
	var obj = {
				id: 1,
				name: 'andy',		//简单类型
				msg: {
					age: 18			//对象类型
				},
				color: ['pink', 'red']	//数组类型
			};
			var o = {};
```

```javascript
	//封装函数
			function deepCopy(newobj, oldobj) {
				for (var k in oldobj) {
					//判断我们的属性值属于哪种数据类型，是简单还是复杂
					//1.获取属性值 oldobj[k]
					var item = oldobj[k];
					//2.判断这个值是否是数组
					if (item instanceof Array) {
						newobj[k] = [];
						deepCopy(newobj[k], item);
					} else if (item instanceof Object) {
						//3.判断这个值是否是对象
						newobj[k] = {};
						deepCopy(newobj[k], item)
					} else {
						//4.属于简单数据类型
						newobj[k] = item;
					}
				}
			}
			deepCopy(o, obj);
			console.log(o);
			o.msg.age = 20;
			console.log(obj);
```

**注：**因为数组也属于Object，所以判断是否是array类型要放在判断是否是对象类型之前

**测试结果：**

![3](D:\web前端\JavaScript note\js进阶\img\11.15\3.png)

obj成功拷贝，并且证实了改变o.ms



### 正则表达式

**正则表达式**是用于匹配字符串中字符组合的模式。在JS中，正则表达式也是对象。

正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如**验证表单**：用户名表单只能输入英文字母、数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词，或者从字符串中获取我们想要的特定部分（提取）等。

#### 创建正则表达式

1.利用RegExp对象来创建 正则表达式

```js
var regexp = new RegExp(/表达式/);
```

2.利用字面量创建正则表达式

```
var rg = /123/;
```

**注**:正则表达式里面不需要加引号,不管是数字型还是字符串型

#### 测试正则表达式test

test()正则对象方法,用于检测字符串是否符合该规则,该对象 会返回true或false,其参数是测试字符串

```js
regexobj.test(str)	//这句话是检测str文本是否符合正则表达式规范
```

其中regexObj 是写的正则表达式

str 是我们要测试的文本

#### 正则表达式的组成

一个正则表达式可以由简单的字符组成,如/abc/,也可以是简单和特殊字符的组合,比如/ab*c/.其中特殊字符也被称为元字符,在正则表达式中是具有特殊意义的专用符号.如:^ ,$,+等.

##### 边界符

正则表达式中

边界符用来提示字符所处的位置,主要有两个字符

| 边界符 | 说明                         |
| :----- | ---------------------------- |
| ^      | 表示匹配行首的文本(以谁开始) |
| $      | 表示匹配行尾的文本(以谁结束) |

```js
var rg = /abc/;	//只要包含有abc这个字符串的返回的都是true
console.log(rg.test('abc'));	//true
console.log(rg.test('aabc'));	//true
```

```js
var reg = /^abc/;		// 以abc开头的就是true
console.log(rg.test('abc'));	//返回true
console.log(rg.test('abcd'));	//返回true
console.log(rg.test('aabc'));	//返回false
```

```js
var reg1 = /^abc$/;	// 精确匹配 代表必须是abc这个字符串
```

如果^和$在一起,代表精确匹配

##### 字符类

[]表示有一系列字符可供选择，只要匹配其中一个就可以了

```js
var rg =  /[abc]/;	//只要包含有a或者有b或者含有c就返回true
console.log(rg.test('andy')); //true

var rg = /^[abc]$/; //三选一，只有是a或b或c 这三个字母才返回true
console.log(rg.test('a')); 	// true
console.log(rg.test('b')); 	//true
console.log(rg.test('c')); 	//true
console.log(rg.test('abc')); 	//false
```

[-] 方括号内部范围符-

```js
var rg1 = /^[a-z]$/; //26个英文字母任何一个字母且只有一个返回true
console.log(rg.test('a')); 	//true
console.log(rg.test('z')); //true
console.log(rg.test('A)); //false
```

字符组合

```js
var reg = /^[a-zA-Z0-9_-]$/; //26个英文字母（大小写）任何一个字母以及任何一个数字或者 -和 _ 且仅有一个
console.log(reg.test(8));//true
console.log(reg.test(-));//true
```

[^] 方括号内部取反符^

前面的^在[]外，是边界符，但是在[]里就不是了,千万和边界符^弄混

```js
var reg1 = /^[^a-zA-Z0-9_-]$/; //^在[]里表示取反  
//代表里面不能有a-z,A-Z,0-9,-,_
console.log('!'); //true
```

##### 量词符

量词符 用来设定某个模式出现的次数

| 量词  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n次到m次     |

**量词***

```js
var reg = /^a*$/;	//重复零次或者多次都是true（不能出现别的字符）
console.log(reg.test(''));		//true
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//true
```

**量词+**

````js
var reg = /^a+$/;	//重复一次或者多次都是true（不能出现别的字符）
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//true
````

**量词？**

```
var reg = /^a?$/;	//重复一次或者0次都是true（不能出现别的字符）
console.log(reg.test(''));		//true
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//false
```

**量词{n}**

```js
//{3 }就是重复三次
var reg = /^a{3}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true

//{3, }就是大于等于3次
var reg = /^a{3,}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true
console.log(reg.test('aaaaa'));	//true
```

**量词{n,m}**

```js
//{3,6}就是大于等于3次且小于等于6次
var reg = /^a{3,6}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true
console.log(reg.test('aaaaa'));	//true
```

```js
var reg = /^[a-zA-Z0-9_-]{6,16}$/;
//用户只能输入英文字母数字以及-_并且为6-16位
//{6,16} 中间不要有空格
console.log(reg.test('andy_red08')); //true
console.log(reg.test('andy!007')); //false
```

##### 案例

**用户名验证**

功能：1.如果用户名输入合法，就提示用户名合法且颜色为绿色

​			2.如果用户名不合法，后面提示信息为不合法且颜色为红色

​			3.当表单失去焦点就开始验证

​			4.如果符合规范，就在后面的span标签添加right类

​			5.如果不符合规范，就在后面的span标签添加wrong类

**代码：**

```html
<input type="text" class = "uname"><span>请输入用户名</span>
		<script>
		var reg = /^[a-zA-Z0-9-_]{6,16}$/;
		var uname = document.querySelector('.uname');
		var span = document.querySelector('span');
		uname.onblur = function(){
			if (reg.test(this.value)){
				span.className = 'right';
				span.innerHTML = "用户名格式正确";
			}else{
				span.className = 'wrong';
				span.innerHTML = "用户名格式错误";
			}
		}
		</script>
```

##### 括号总结

中括号[],字符集合，匹配方括号中的任意字符

```js
var reg = /^[abc]$/;
//a||b||c
```

大括号{} 量词符，里面表示重复次数

```js
var reg = /^abc{3}$/; //它只是让c重复三次
console.log(reg.test('abcabcabc'));
//false
console.log(reg.test('abccc'));
//true
```

小括号表示优先级(把小括号里面的看成一个整体)

```js
var reg = /^(abc){3}$/;//它是让abc重复三次
console.log(reg.test('abcabcabc'));
//true
console.log(reg.test('abccc'));
//false;
```

##### 预定义类

| 预定义类 | 说明                                                       |
| -------- | ---------------------------------------------------------- |
| \d       | 匹配0-9之间的任一数字，相当于[0-9]                         |
| \D       | 匹配所有0-9以外的字符，相当于[ ^0-9]                       |
| \w       | 匹配任意的字母，数字和下划线，相当于[A-Za-z0-9_]           |
| \W       | 除所有字i母，数字和下划线意外的字符，相当于[ ^A-Za-z0-9_]  |
| \s       | 匹配空格(包括换行符、制表符、空格符等)，相当于[\t\r\n\v\f] |
| \S       | 匹配非空格的字符，相当于[ ^\t\r\n\v\f]                     |

座机号码验证：两种格式，一个是 010-12345678或者 0110-1234567

```js
//正则里面的或 |
//var reg = /^\d{3}-\d{8}|\d{4}-\d{7}$/;
var reg = /^\d{3,4}-\d{7,8}$/;
```

##### 正则替换

**replace替换**

replace方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式,返回值是一个替换完毕的新字符串

```js
//替换
var str = 'andy和red';
var newstr = str.replace(/andy/,'baby');
//把andy替换成baby
```

**敏感词替换案例**

```html
<textarea name = "" id="mes"></textarea><button>提交</button>
		<div></div>
		<script>
		var text = document.querySelector('textarea');
		var btn = document.querySelector('button');
		var div = document.querySelector('div');
		btn.onclick = function(){
			div.innerHTML = text.value.replace(/激情/,'**');
		}
		</script>
```

但这样只能过滤第一个敏感词，不能过滤所有的

如图

![1](D:\web前端\JavaScript note\js进阶\img\11.16\1.png)

##### 正则表达式参数

```
/表达式/[switch]
```

switch(也称为修饰符)按照什么样的模式来匹配，有三种值：

- g：全局匹配
- i：忽略大小写
- gi：全局匹配且忽略大小写

所以只需要改动一处

```js
div.innerHTML = text.value.replace(/激情/g,'**');
```

这样就可以实现全局匹配了

想要实现多个敏感词只需要用|，如

```js
div.innerHTML = text.value.replace(/激情|xx|xxx/g,'**');
```

就可以实现