## js进阶

## 面向对象编程

### 创建对象



```javascript
class Star{
	constructor(uname,age){
	this.uname = uname;
	this.age = age;
	}
}
//利用类创建对象 new
var ldh = new Star('刘德华',18);
```



**注：**首字母要大写



`constructor函数`是构造函数，接受传过来的参数同时返回实例对象，并且只要new生成实例时，就会自动调用这个函数，不写也会自动生成



生成实例 new 不能省略



创建类时，类名后面不能加小括号，生成实例，类名后面加小括号，构造不需要加function。



#### **类中添加方法**



```javascript
class Star{
	constructor(uname,age){
	this.uname = uname;
	this.age = age;
	}
	sing(song){
	console.log(this.uname + song);
	}
}
	var ldh = new Star('刘德华',18);
	ldh.sing('冰雨');
```



类的共有属性放到constructor里面,利用类创建对象 new



类里的函数不需要写function,多个函数方法之间不需要加逗号分隔 (js类外的函数需要)



### **类的继承**



```javascript
class Father{
	constructor(x,y){
	this.x = x;
	this.y = y;
	}
	sum(){
	console.log(this.x + this.y);
	}
}
class Son extends Father{
	constructor(x,y){
	super();
	}
}
var son = new Son(1,2);
son.sum();
```



**注:**son继承了父亲的sum(),但是如果在son的构造函数中,如果不调用父类的构造函数而是写自己的构造函数,当new一个son的实例去调用继承的sum方法时就会报错,因为sum()方法里的x,y是father的,而son创建时构造的是自己的不是father的,所以若想使用父类的方法,就需要在构造函数中调用父类的构造函数.



#### **super关键字**



```javascript
class Father{
	say(){
	return '我是爸爸';
	}
}
class Son extends Father{
	say(){
		console.log(super.say() + '的儿子');
	}
}
var son = new Son();
son.say();
```



继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,有的话就近原则先执行子类的,如果子类里面没有,就去父亲那里找,如果有,就执行父亲的这个方法.



比如这个例子,直接通过super.say来调用父类的say方法.



#### **子类拓展私有方法**



```javascript
class Son extends Father{
	constructor(x,y){
	super(x,y);
	this.x = x;
	this.y = y;
	}
	subtract(){
	console.log(this.x + this.y);
	}
}
var son = new Son(5,3);
son.subtract();
son.sum();
```



子类继承父类的sum方法,同时私有subtract方法



利用super调用父类的构造函数,这样son就能使用父类的方法sum,再定义自己的构造函数，同时也写上自己的构造函数内容



**注:**super必须在子类this之前调用，即super()必须写再最前面



### **使用类的注意事项**



```javascript
class Star{
 	constructor(uname,age){
 		this.uname = uname;
 		this.age = age;
 		this.sing();
 	}
 	sing(){
 	console.log(this.uname);
 	}
}
var ldh = new Star('刘德华');
```



在es6中类没有变量提升,所以必须先定义类,才能通过类实例化对象,二者不能更换顺序



类里面的共有的属性和方法一定要加this使用



### 关于类里面this指向问题



哪个对象调用，this就指向谁。



```javascript
this.btn = document.querySelector('button');
this.btn.onclick = this.sing;
```



```javascript
sing(){
	console.log(this);
}
dance(){
	// 这个dance里面的this指向的是实例对象ldh，因为ldh调用了这个函数
	_that = this;
	console.log(this);
}
```



btn调用了sing，所以sing方法里面的this指向的是btn这个按钮



构造函数constructor里面的this指向实例对象，方法里面的this指向这个方法的调用者

### 面向对象的练习



**功能：**



1.点击tab栏可以切换



2.点击+号，可以添加tab项和内容项



3.点击×号，可以删除当前的tab项和内容项



4.双击tab项文字或者内容项文字，可以修改里面的文字内容



**抽象对象：**Tab对象



该对象有切换，添加，删除，修改功能



**添加功能：**



第一步：创建新的选项卡li和新的内容section



第二步：把创建的两个元素追加到对应的父元素中



以前的做法：动态创建元素createElement，但是元素里面内容较多，需要innerHTML赋值再appendChild追加到父元素里面



现在的做法：利用insertAdjacentHTML()可以直接把字符串格式元素添加到父元素里面



**编辑功能：**



双击事件是：ondblclick



如果双击文字，会默认选定文字，此时需要双击禁止选中文字:



window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();



核心思路：双击文字的时候，在里面生成一个文本框，当失去焦点或者按下回车然后把文本框输入的值给原先的元素即可



js代码如下：



```javascript
var that;
class Tab{
	constructor(id) {
	    //获取元素
		that = this;
		this.main = document.querySelector(id);	
		this.add = this.main.querySelector('.tabadd');		//因为add按钮不会动态添加,所以不用放在updateNode里
		//获取li的父元素
		this.ul = this.main.querySelector('.firstnav ul:first-child');
		//section的父元素
		this.fsection = this.main.querySelector('.tabscon');
		this.init();
	}
	//init初始化操作,让相关元素绑定事件
	init(){
		this.updateNode();
		this.add.onclick = this.addTab;
		for(var i = 0;i<this.lis.length;i++){
			this.lis[i].index = i;
			this.lis[i].onclick = this.toggleTab; //函数加小括号和不加的区别:不加点击才调用,加了后页面加载就调用
				// 调用toggleTab的是li,所以toggleTab里的this指向的是li
			this.remove[i].onclick = this.removeTab;
			this.spans[i].ondblclick = this.editTab;
			this.sections[i].ondblclick = this.editTab;
		}
	}
	//获取所有的li和section 因为这两个随时可能更新,因为我们动态添加元素需要重新获取对应的元素
	updateNode(){
		this.lis = this.main.querySelectorAll('li');
		this.sections = this.main.querySelectorAll('section');
		this.remove = this.main.querySelectorAll('.icon-guanbi');
		this.spans = this.main.querySelectorAll('.firstnav li span:first-child');
	}
	// 1.切换功能
	toggleTab(){
		// console.log(this.index);
		that.clearClass();	//利用构造函数里的this调用这个方法才能li和sections都作用到
		this.className = 'liactive';	//this指向的是lis而非构造函数里的this,所以需要用全局变量that
		that.sections[this.index].className = 'conactive';	// conactive绑定的样式为下边框消失
	}
	// 清除li和section名字的函数
	clearClass(){
		for(var i = 0;i<this.lis.length;i++){
			this.lis[i].className = '';
			this.sections[i].className = '';
		}
	}
	
	//添加功能
	addTab(){
		that.clearClass();
		var random = Math.random();
		//创建li元素和section元素
		var li = '<li class = "liactive"><span>新选项卡</span><span class = "iconfont icon-guanbi">×</span></li>';	
		var section = '<section class = "conactive">新内容'+random+'</section>';
		//把两个元素追加到对应的父元素里面
		that.ul.insertAdjacentHTML('beforeend',li); //把li字符串追加到父元素里面,在最后面追加
		that.fsection.insertAdjacentHTML('beforeend',section); //把li字符串追加到父元素里面,在最后面追加
		that.init();	// 识别新加的li和section并让相关元素绑定事件
	}
	//删除功能
	removeTab(e){	//e是事件对象 e是event的意思，每一个元素都有的，只是一般没显示出来
		e.stopPropagation();	//阻止冒泡 ,防止触发li的切换点击事件
		var index = this.parentNode.index;
		console.log(index);
		that.lis[index].remove();
		that.sections[index].remove();
		that.init();	//因为数量发生变化所以需要重新获取元素
		// 当我们删除的不是选中状态的li时,让之前选中的li保持选中不变
		if (document.querySelector('.liactive')) return;
		// 当我们删除选中状态的这个li时,让它的前一个li处于选定状态
		index--;
		//手动调用点击事件,不需要鼠标触发
		//若删除了剩的最后一个,由于that.lis[index]为false,所以不处罚点击事件
		that.lis[index] && that.lis[index].click();
		
	}
	//修改功能
	editTab(){
		//将原来的文字赋值给str
		var str = this.innerHTML;
		//双击禁止选定文字
		window.getSelection?window.getSelection().removeAllRanges():document.selection.empty();
		//生成一个文本框
		this.innerHTML = '<input type="text"/>';
		var input = this.children[0];
		input.value = str;	//将之前里面的文字拿到文本框里
		input.select();     //让文本框里的文字处于选中状态
		input.onblur = function(){
			this.parentNode.innerHTML = this.value;
			// input里面的内容将input取代了所以input消失了，比如生成文本框后<span><input>xxx</span>
			//this在上面指向的是span，span的第一个孩子是input，input的父节点是span
			//所以span里的东西变成了input里的值（input调用的函数所以onblur绑定的函数里的this指向的是input）
		};
		//按下回车也可以把文本框里面的值给span
		input.onkeyup = function(e){
			if (e.keyCode === 13){
				//手动调用表单失去焦点事件，不需要鼠标离开操作
				this.blur();	//这里this指向的是input,因此也能调用onblur方法
			}
		}
	}
}
var tab = new Tab('#tab');
```



**注：**等之后学到bind()，就不用在开始定义一个全局变量that，可以直接用bind来实现，具体看函数进阶笔记的改变this指向的办法3-bind()



## 构造函数和原型



在面向对象的语言中，都存在类的概念。类就是对象的模板，对象就是类的实例。但是在ES6之前，JS没有引入类的概念，且对象不是基于类创建的，二十用一种成为构造函数的特殊函数来定义对象和它们的特征。



### 创建对象



创建对象可以通过以下三种方式



**1.对象字面量**



```javascript
var objectName = {
    属性名1 : 属性值1,
    属性名2 : 属性值2,
    ...
    属性名n : 属性值n
};
```



**2.new Object()**



```javascript
var obj  = new Object();  //Object为系统的构造函数 
obj.name="小明";  //添加属性  ————对象名.名字=值;
obj.eat=function(){   //添加方法  ————对象名.名字=函数;
        console.log("做饭");
    };
console.log(obj.name); //调用属性
obj.eat(); //调用方法
```



**3.自定义构造函数**



```javascript
function Star(uname,age){
	this.uname = uname;
	this.age = age;
	this.sing = function(){
		console.log('我会唱歌');
	}
}
var ldh = new Star('刘德华',18);
console.log(ldh);
ldh.sing();
```



**实例成员**就是构造函数内部通过this添加的成员 uname age sing 就是实例成员



实例成员(构造函数内部成员)只能通过实例化的对象来访问



```javascript
console.log(ldh.uname);√
ldh.sing();
//console.log(Star.uname)×  不可以通过构造函数来访问实例成员
//静态成员 在构造函数本身上添加的成员 sex就是静态成员
Star.sex = '男';
// 静态成员只能通过构造函数来访问
console.log(Star.sex); √
//console.log(ldh.sex);× 静态成员不能通过对象来访问
```



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811353931-61a0e51b-4cf2-4027-b8d6-bf818b0c85c6.png)



构造函数方法很好用，但是存在`**浪费内存的问题**`



每创建一个对象就要分配一个内存，开辟的内存空间是不一样的，它们存的地址是不一样的。所以就需要构造函数原型prototype来解决这个问题。



### 构造函数原型 prototype



构造函数通过原型分配的函数时所有对象所共享的



JS规定，每一个构造函数都有一个prototype属性，指向另一个对象，**注：**这个prototype就是一个对象。这个对象的所有属性和方法，都会被构造函数所拥有。（它不会再开辟新的内存空间）



**我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法**



```javascript
Star.prototype.sing = function(){
	console.log('我会唱歌');
}
var ldh = new Star('刘德华',18);
var zxy = new Star('张学友',19);
ldh.sing();
zxy.sing();
```



**一般情况下，我们的公共属性定义到构造函数里面，公共方法我们放到原型对象身上**



### 对象原型`__proto__`



```javascript
//在对象身上系统给自己添加一个__proto__ 指向我们构造函数的原型对象
console.log(ldh.__proto__ ===Star.prototype);
//true
//证明__proto__指向了构造函数的原型对象，二者等价
//方法的查找规则：首先先看ldh，对象身上是否有sing方法，如果有就执行这个对象上的sing，如果没有sing这个方法，因为有__proto__的存在，就去构造函数原型对象prototype身上去查找
```



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811377110-6f1c17a7-fc5c-41e1-8c7f-95da52308ad8.png)



对象原型( **proto** )和构造函数原型对象（prototype）里面都有一个构造函数constructor，指向的都是**最开始定义的构造函数**本身



constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数



**很多情况下，我们需要手动的利用constructor这个属性指回原来的构造函数**



```javascript
//第一种
Star.prototype.sing = function(){
	console.log('我会唱歌');
};
Star.prototype.movie = function(){
	console.log('我会拍电影');
};
//第二种
Star.prototype = {
	sing:function(){
		console.log('我会唱歌');
	},
	movie:function(){
		console.log('我会拍电影');
	}
}
```



把原型对象合并写成上面的第二种写法后，就不指回原来的构造函数了。



**原因是：**上面的第一种写法，是在对象中添加这个方法，而下面的是让原型对象等于了一个对象，相当于用后面的对象把原先的Star.prototype里面这个对象全都覆盖了，覆盖之后，Star.prototype里面就没有constructor这个属性了，也就是说把原来Star.prototype里面的constructor属性被覆盖掉了,没有constructor就没有办法指回原来的构造函数了。所以需要手动的利用constructor这个属性指回原来的构造函数。

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811418864-e103d9fd-76cd-4938-a715-c68acfbb629e.png)





*通过打印发现里面没有constructor这个属性*



**手动添加：**



```javascript
Star.prototype = {
constructor:Star,
sing:function(){
console.log('sing');
},
movie:function(){
console.log('movue');
}
}
```



添加后又指回了原来的构造函数了



### 原型链详解图



![img](https://cdn.nlark.com/yuque/0/2021/webp/23070022/1636811219496-cc83d979-3c03-417b-81c9-994bcc9e2126.webp)



#### JS成员查找机制



1.当访问一个对象的属性（包括方法）时，首先查找**这个对象自身**有没有该属性



2.如果没有就查找他的原型（也就是`__proto__`指向的**prototype原型对象**）



3.如果还没有就查找原型对象的原型（**Object的原型对象**）



4.依次类推一直到找到Object为止（**null**）



```javascript
function Star(uname,age){
	this.uname = uname;
	this.age = age;
}
Star.prototype.sing = function() {
	console.log('我会唱歌');
}
// Star.prototype.sex = '女';
//Object.prototype.sex = '男';
var ldh = new Star('刘德华',18);
//ldh.sex = '男';
console.log(ldh.sex);
```



如果都注释掉，就找不到sex这个成员了，控制台输出为`undefined`



原型对象函数里面的this 指向的也是实例对象 ldh，也是谁调用就指向谁



#### 扩展内置对象



给数组的原型对象加一个sum方法



```javascript
Array.prototype.sum = function(){
	var sum = 0;
	for (var i = 0;i<this.length;i++){
		sum += this[i];
	}
	return sum;
}
var arr = [1,2,3];
console.log(arr.sum());
console.log(Array.prototype);
```



打印结果

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811445362-abb7a56f-bae6-48d0-a430-bf92472f73c4.png)





**注：**数组和字符串的内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式，不然会把原来里面的其它内置函数也覆盖导致消失。（和自己定义的对象的原型对象覆盖操作只需要添加构造函数指回去不同，它指回去也不行）



## 继承



### call方法



call()可以调用函数



它的主要作用是实现继承



```javascript
function fn(x,y){
console.log("我想喝水");
console.log(this);
console.log(x+y);
}
var o ={
name :'andy'
};
//fn();
//1.call() 可以调用函数
//fn.call();
//2.call() 可以改变这个函数的this指向
//fn.call(o); 此时这个函数的this指向的是对象o
fn.call(o,1,2) //此时，1和2分别传入x和y，o是用来改变函数的this指向的，是不参与参数的传递的。
//可以写为fun.call(thisArg当前调用函数this的指向对象,arg1,arg2…传递的普通参数)
```



### 借用父构造函数继承属性



```javascript
//借用父构造函数继承属性
//父构造函数
function Father(uname,age){
//this指向父构造函数的对象实例
this.uname = uname;
this.age = age;
}
//子构造函数
function Son(uname,age){
	// this 指向子构造函数的对象实例，也就是指向Son
	Father.call(this,uname,age); 	// 让子构造函数去调用父构造函数
}
var son = new Son();
```



**备注**：目前发现的call()和super()的区别。都可以起到继承的作用（调用别的对象的方法，不同的是写法不同）super需要class Father ,在里面写构造函数，然后再class Son extends Father，然后再在Son里使用super调用父类函数



```javascript
class Father{
	say(){
	return '我是爸爸';
	}
}
class Son extends Father{
	say(){
		console.log(super.say() + '的儿子');
	}
}
var son = new Son();
son.say();
```



如上（以上为面向对象文件笔记中的super关键字调用父类普通函数的代码）



**也就是说es5主要用这种构造函数继承的方法（使用call()），es6继承主要是class的继承** （以上备注为个人观点）



es5使用call或apply改变this指向（之后函数进阶会讲到），并执行了父类的构造函数,被称作**对象冒充继承**



```javascript
function Father(uname,age){
	//this指向父构造函数的对象实例
	this.uname = uname;
	this.age = age;
}
//2.子构造函数
function Son(uname,age,score){
	//this 指向子构造函数的对象实例
	Father.call(this,uname,age);
	this.score = score;
}
var son = new Son('儿子',18,100);
console.log(son);
```



继承了Father的uname和age，同时也有自己的score属性，如图



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811489870-1765662c-87b1-4813-b1ab-25211ca4006c.png)

### 利用原型对象继承



公有方法可以写到原型对象上



```javascript
function Father(uname,age){
	//this指向父构造函数的对象实例
	this.uname = uname;
	this.age = age;
}
Father.prototype.money = function(){
	console.log(10000);
}
//2.子构造函数
function Son(uname,age,score){
	//this 指向子构造函数的对象实例
	Father.call(this,uname,age);
	this.score = score;
}
var son = new Son('儿子',18,100);
console.log(son);
```



比如这个把共有方法money写到father的原型对象里，在控制台打印后发现son里面没有money这个方法。



**原因：**money写到原型对象里而不是构造函数里，son调用的是father的构造函数而不是原型对象，所以找不到这个方法。



***如果让子构造函数原型对象等于父构造函数原型对象呢？\***



给son的原型对象加一个私有的exam方法



```javascript
function Son(uname,age,score){
	Father.call(this,uname,age);
	this.score = score;
	}
Son.prototype = Father.prototype;
//这个是子构造函数专门的方法
Son.prototype.exam = function(){
	console.log('孩子考试');
}
```



此时son里面出现了money方法和exam方法没有问题。但打印Father时，发现父亲也有exam，二者同步了，exam方法不是son私有的了。所以不能这样直接赋值，如果修改了子原型对象，父原型对象也会跟着一起变化



**正确方法：**



创建一个中间层



```javascript
Son.prototype = new Father();
//这个是子构造函数专门的方法
Son.prototype.exam = function(){
	console.log('孩子考试');
}
var son = new Son('刘德华',18,100);
console.log(son);
console.log(Father.prototype);
console.log(Son.prototype.constructor);
```



Son的原型对象等于实例化的父构造函数



但这样Son的原型对象的构造函数就指向Father了，所以需要利用constructor来指回原来的构造函数



```javascript
//Son.prototype = Father.prototype;	这样直接赋值会有问题，修改子原型对象，父原型对象也会跟着一起变化
Son.prototype = new Father();
//如果利用对象的形式修改了原型对象，要用constructor指回原来的构造函数
Son.prototype.constructor = Son;
```



这样就指回来了（指回Son）



**图解**



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811527634-5cdb9781-1cdd-4766-949a-b6ed86582cb6.png)



### ES6类的本质



1.class本质还是function



2.类的所有方法都定义在类的prototype属性上



3.类创建的实例，里面也有`__proto__`指向类的prototype原型对象



4.所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已



5.所以ES6的类其实就是语法糖



6.语法糖：语法糖就是一种便捷写法，简单理解，有两种方法可以实现同样的功能，但是一种写法更加清晰方便，那么这个方法就是语法糖



**类的本质其实还是一个函数，我们也可以简单的认为，类就是构造函数的另外一种写法**



**ES6之前通过 构造函数+原型实现面向对象编程**



1.构造函数有原型对象prototype



2.构造函数原型对象prototype 里面有constructor指向构造函数本身



3.构造函数可以通过原型对象添加方法



4.构造函数创建的实例对象有`__proto__`原型指向构造函数的原型对象



ES6 通过类实现面向对象编程



```javascript
class Star{

}
console.log(typeof Star);
console.log(Star.prototype);
```



## ES5中的新增方法



### 数组方法



迭代遍历方法：forEach(),map(),some(),every();



#### **forEach()**



```javascript
array.forEach(function(currentValue,index,arr))
```



-  currentValue :数组当前项的值 
-  index : 数组当前项的索引 

-  arr : 数组对象本身  

```javascript
var forEach(function(value,index,array){
console.log('每个数组元素'+value);
console.log('每个数组元素的索引号'+index);
console.log('数组本身'+array);
sum += value;
})
console.log(sum);
```



#### filter()



filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组



**注：**它直接返回一个新数组



```javascript
array.filter(function(currentValue,index,arr))
```



currentValue:数组当前项值



index：数组当前项的索引



arr：数组对象本身



```javascript
var arr = [12,64,4,88];
var newArr = arr.filter(function(value,index){
return value >= 20;
});
console.log(newArr);
```



#### some()



```javascript
array.some(function(currentValue,index,arr))
```



-  some()方法用于检测数组种的元素是否满足指定条件。通俗来说就是查找数组中是否有满足条件的元素 
-  注:它的返回值是布尔值，如果查找到这个元素，就返回true，查找不到就返回false 

-  如果找到第一个满足条件的元素，则终止循环，不再继续查找 
-  currentValue：数组当前项的值 

-  index：数组当前项的索引 
-  arr：数组对象本身  

```javascript
var arr = [10,30,4];
var flag = arr.some(function(value){
	return value < 3;
})
console.log(flag);

var arr1 = ['red','pink','blue'];
var flag1 = arr1.some(function(value){
	return value == 'pink';
})
console.log(flag1);
```



##### some()和forEach(),filter()的区别



在forEach()里面遇到return不会终止，但some不一样，some遇到return会终止遍历迭代，效率更高



在some里return true会停止迭代。必须return true，说明找到了这个元素，然后迭代才终止。



**filter**和forEach一样遇到retuen也不会终止迭代



所以在查找唯一元素的时候应该用some，效率更高，是最好的选择



### 字符串方法



#### trim()



```javascript
//trim 方法去除字符串两侧空格
var str = '		andy	';
console.log(str);
var str1 = str.trim();	//获得去除左右两侧空格的新字符串，但不会去除字符之间的空格
console.log(str1);
```



```javascript
<input type = "text"> <button>点击</button>
<div></div>
<script>
var input = document.querySelector('input');
var btn = document.querySelector('button');
var div = document.querySelector('div');
btn.onclick = function(){
if (input.value === ''){
	alert('请输入内容')
}else{
console.log(input.value);
console.log(input.value.length);
div.innerHTML = input.value;
}
}
</script>
```



按上面这段代码来写，当输入一个空格时，由于判断值时里面有一个空格所以判断不为空不会出现提示。并且当输入的内容携带空格时，也不能识别出把空格去掉，因此就需要trim()函数,所以需要改成以下这样



```javascript
var str = input.value.trim();
if (str === ''){
	alert('请输入内容')
}else{
console.log(str);
console.log(str.length);
div.innerHTML = str;
}
```



### Object对象方法



##### Object.keys()



遍历方法，可以遍历属性



##### Object.defineProperty()



定义对象中新属性或修改原有的属性



```javascript
Object.defineProperty(obj,prop,descriptor)
```



- obj:必需。目标对象
- prop：必须。需定义或者修改的属性的名字

- descriptor：必需。目标属性所拥有的特性



Object.defineProperty(）第三个参数descriptor说明：以对象形式{}书写



- value:设置属性的值，默认为undefined
- writable:值是否可以重写。true|false，默认为false

- enumerable:目标属性是否可以被枚举.true|false 默认为false
- configurable:目标属性是否可以被删除或者是否可以再次修改特性true|false 默认为false



```javascript
var obj = {
id:1,
pname:'小米',
price:1999
};
//1.以前的对象添加和修改属性的方式
//obj.num = 1000;
//obj.price = 99;
//console.log(obj);
//2.Object.defineProperty()
Object.defineProperty(obj,'num',{
	value:1000
});
Object.defineProperty(obj,'price',{
	value:9.9
});
//没有这个属性的话就添加，如果有了这个属性就修改原有属性，修改成新定义的值
Object.defineProperty(obj,'id',{
	//不允许修改这个属性值
	writable:false,
});
obj.id = 2;
//尝试修改id看是否能修改
console.log(obj);
//结果id没变还是1
//但如果writable改成true就能修改，writable默认值为false
Object.defineProperty(obj,'address',{
	value:'大连xx小区',
	enumerable:false,
	// enumerable 如果值为false，则不允许遍历，不在方法里写这个属性的话默认的值为false
	configurable:false
	//configurable 如果为false，则不允许删除这个属性，也不允许修改这个属性第三个参数里面的特性（如改成可修改或可遍历），默认值为false.
});
console.log(Object.keys(obj));
delete obj.address;
//原先定义的pname是没有这些属性的，所以可删除可重写，课可遍历
```



## 函数进阶



### 函数的定义和调用



```javascript
//函数的定义方式
//1.自定义函数（命名函数）
function fn(){};
//2.函数表达式（匿名函数）
var fun = function(){};
//3. 利用new Function('参数1','参数2','函数体');
var f = new Function('a','b','console.log(a+b)');
f(1,2);
//但这种方法很少用，效率偏低
//但能通过这种方式得出一个结论：所有函数其实都是Function函数的一个实例对象，前面都是简写模式
//应了JS万物皆对象的说法
```



#### 函数的定义方式



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811622802-62662ee5-c0ca-45c5-a752-4ea45ea976e2.png)

#### 



```javascript
//1.普通函数
function fn(){
	console.log('人生的巅峰');
}
fn();/fn.call()
//2.对象的方法
var o = {
sayHi:function(){
	console.log('人生的巅峰');
}
}
o.sayHi();
//3.构造函数
function Star(){};
new Star();
//4.绑定事件函数
btn.onclick = function(){}; // 点击了按钮就可以调用
//5.定时器函数
setInterval(function() {},1000);//这个函数是定时器自动一秒调用一次
//6.立即执行函数
(function(){
	console.log('人生的巅峰');
})();
//立即执行函数是自动调用
```



### 函数内this的指向



**不同的调用方式决定了this的指向不同**



1.普通函数指向的是window



2.对象的方法this指向的是对象



3.构造函数指向的是实例对象，原型对象里面的this指向的也是实例对象



4.绑定事件函数的this指向的是函数的调用者（btn这个按钮对象）



5.定时器函数指向的对象还是window



6.立即执行函数指向的也是window，他和普通函数的区别就是不需要手动调用



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811684043-27491b8d-5736-4254-bbd7-43f314f6ffdd.png)



#### 改变this指向的方法



##### 1.call()



详情看继承笔记，之前已经学过



##### 2.apply()

![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811717293-b74513b8-0cf6-4702-aa66-9d753d6f6933.png)



和call的区别主要体现在参数不同



第一个参数是this指向，第二个参数必须是一个数组



```javascript
function fn(){
console.log(1);
};
fn.apply(o);
// 也是调用函数
//但是它的参数必须是数组（伪数组）
fn.apply(o,['pink']); √
fn.apply(o,1); 		  × 会报错
```



apply的主要应用 ：比如我们可以利用apply借助于数学内置对象求最大值



// Math.max();



```javascript
var arr =[1,66,3,99,4];
//Math.max.apply(null,arr); 指传递的this指向为空，不改变this指向
var max = Math.max.apply(Math,arr);	//严格模式用null可能有问题
var min = Math.min.apply(Math,arr);
console.log(max,min);
```



##### 3.bind()



传递的参数和call一样，不是数组



主要区别：只是改变this指向，生成新的函数，但不会自己调用



![img](https://cdn.nlark.com/yuque/0/2021/png/23070022/1636811767740-377d7973-160e-4abb-83f0-4b20b0521454.png)



```javascript
var o = {
name:'andy'
};
function fn(a,b){
console.log(a+b);
};
fn.bind(o);
//它只是绑定但不会执行(调用)，可以改变原来函数内部的this指向，返回的是原函数改变this之后产生的新函数
var f = fn.bind(o,1,2); // 接收这个新函数
f();					//调用
```



如果有的函数我们不需要立即调用但是又想改变这个函数内部的this指向，此时使用bind方法



```javascript
//如果有的函数我们不需要立即调用但是又想改变这个函数内部的this指向，此时使用bind方法
//我们有一个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelector('button');
btn.onclick = function() {
this.disabled = true;
setTimeout(function(){
	this.disabled = false;	//定时器里面this指向的是window
}.bind(this),3000)		//这个this指向的是btn这个对象
}
```



```javascript
//我们有多个按钮，当我们点击之后，就禁用这个按钮，3秒之后再开启这个按钮
var btn = document.querySelectorAll('button');
for(var i=0;i<btn.length;i++){
	btn[i].onclick = function() {
	this.disabled = true;
	setTimeout(function(){
			this.disabled = false;	//定时器里面this指向的是window
		}.bind(this),3000)		//这个this指向的是btn这个对象，这样就将定时器从window绑定到了btn这个对象上
	}
}
//定时器是异步函数，for循环时立即执行。for循环嵌套定时器，btn[i]就不能当作this指向，因为i的数量不再对等。
```



**bind应用面向对象tab栏**



代码见面向对象笔记



如在切换tab里，toggleTab函数里既需要构造函数里的this有需要构造函数里的this.lis[i]，所以可以用bind



```javascript
this.lis[i].onclick = this.toggleTab.bind(this.lis[i],this);

toggleTab(that) // 把上面绑定的this值传入名为that，但这个函数指向的依旧是this.lis[i]
//其它方法同理
```



这么写省的定义全局变量that了，可以避免像之前那样全局变量that的使用



##### **总结**



call apply bind 总结



**相同点：**都可以改变函数内部的this指向



**区别点：**1.call和apply都会调用函数并且改变函数内部this指向



​			  2.call和apply传递的参数不一样，call传递参数aru1，aru2形式，apply必须数组形式[arg]



​			  3.bind不会调用函数，可以改变函数内部this指向



**主要应用场景：**



1.call经常做继承



2.apply经常和数组有关系，比如借助数学对象实现数组最大值最小值



2.bind 不调用函数，但是能改变this指向，比如改变定时器内部的this指向



### 严格模式



JS除了提供正常模式外，还提供了**严格模式**。ES5的严格模式是采用具有限制性JS变体的一种方式，即在严格的条件下运行JS代码



严格模式在IE 10以上版本的浏览器中才会被支持，旧版浏览器中会被忽略



严格模式对正常的JS语义做了一些更改



1.消除了JS语法的一些不合理，不严谨，减少了一些怪异行为



2.消除代码运行的一些不安全之处，保证代码运行的安全



3.提高编译器效率，增加运行速度



4.禁用了在ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的JS做好铺垫，比如一些保留字如：class，enum，export，extends，import，super不能做变量名



##### 开启严格模式



严格模式可以应用到整个脚本或者个别函数中，因此使用时，我们可以将严格模式分为**为脚本开启严格模式**和**为函数开启严格模式**两种情况



为整个脚本开启严格模式，需要在所有语句之前放一个特定语句‘use strict’;



```javascript
<script>
'use strict';
// 下面写的所有的代码就会按照严格模式来执行
</script>
```



或者写在立即执行函数里，也可以起到为整个脚本开启严格模式的作用



```javascript
<script>
(function(){
	'use strict';
})();

</script>
```



只给一个函数开启严格模式



```javascript
function fn(){
'use strict';
//下面的代码按照严格模式执行
}
function fun(){
//里面的还是按照普通模式执行
}
```



##### 严格模式中的变化



1.以前一个变量可以不声明直接赋值使用，严格模式必须先声明再使用



2.不能在严格模式下随意删除已经声明好的变量



**严格模式下this指向问题**



以前在全局作用域函数中的this指向window对象，严格模式下全局作用域中的this是undefined



以前构造函数时不加new也可以调用，当普通函数，this指向全局对象。严格模式下，如果构造函数不加new调用，this会报错



new实例化的构造函数指向创建的对象实例



定时器this还是指向window



事件，对象还是指向调用者



##### 函数变化



函数里不能有重名的参数



函数必须声明在顶层，JS会引入“块级作用域”。为了与新版本接轨，不允许在非函数的代码块内声明函数



例子:



```javascript
if(true){
	functioon f(){}
	f();
}
for(var i=0;i<5;i++){
	function f2(){}
	f2();
}
function baz(){
function ait(){}
}
```



前两种不行，会报语法错误



最后一种在严格模式下可行



### 高阶函数



高阶函数是对其它函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出



```javascript
function fn(callback){
	callback&&callback();	//相当于先判断是否有callback有则执行
}
fn(function(){alert('hi')});
```



```javascript
function fn(){
	return function(){}
}
fn();
```



此时fn就是一个高阶函数



函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用，最典型的就是作为回调函数



### 闭包



##### 变量作用域



变量根据作用域的不同分为两种：全局变量和局部变量



1.函数内部可以使用全局变量



2.函数外部不可以使用局部变量



3.当函数执行完毕，本作用域内的局部变量会销毁



##### **什么是闭包**



**闭包**指有权访问另一个函数作用域中变量的函数



简单理解就是，一个作用域可以访问另外一个函数内部的局部变量



```javascript
function fn(){
	var num = 10;
	function fun(){
	console.log(num);
	}
	fun();
}
fn();
// fun这个函数作用域，访问了另外一个函数fn里面的局部变量num
//这里的fun()是闭包
```



```javascript
//fn外面的作用域可以访问fn内部的局部变量
function fn(){
	var num = 10;
	function func(){
		console.log(num);
	}
	return fun;
}
var f = fn();
f();
//类似于
//var f = function fun(){
//	console.log(num);
//}
```



也可以写成以下这种写法比较简便



```javascript
function fn(){
var num = 10;
return function(){
	console.log(num);
}
//只要返回的是函数就是属于高阶函数
//所以返回这个函数也是闭包的主要实验思路
//闭包是典型的高阶函数
}
var f = fn();
f();
```



##### 闭包的主要作用



延伸了变量的作用范围



闭包可以用在许多地方。它的最大用处有两个，一个是**可以读取函数内部的变量**，另一个就是**让这些变量的值始终保持在内存中**，不会在调用后被自动清除。



由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。**解决方法是，在退出函数之前，将不使用的局部变量全部删除。**



##### 闭包案例



**案例一：**点击输出当前li索引号



```javascript
<ul class="nav">
			<li>榴莲</li>
			<li>臭豆腐</li>
			<li>鲱鱼罐头</li>
			<li>猪蹄</li>
		</ul>
```



```javascript
		//闭包应用 - 点击li输出当前li的索引号
		//1.我们可以利用动态添加属性的方式
		var lis = document.querySelector('.nav').querySelectorAll('li');
		for (var i=0;i<lis.length;i++){
			lis[i].index = i;
			lis[i].onclick = function(){
				console.log(this.index);
			}
		}
		//2.利用闭包的方式得到当前li的索引号（据说是面试重点！）
		for(var i = 0;i<lis.length;i++){
			//利用for循环创建了四个立即执行函数
			//立即执行函数里面的任何一个函数都可以使用它的i变量
			(function(i){	//这个i是通过下面的i传过来的，每循环一次传递的i不一样
					lis[i].onclick = function(){
						console.log(i);
					}
			})(i);	
		}
		</script>
```



**案例二**：三秒后打印所有li元素的内容



```javascript
//闭包应用2：3秒后打印所有li元素内容
			var lis = document.querySelector('.nav').querySelectorAll('li');
			for (var i = 0; i < lis.length; i++) {
				//for循环是同步任务
				// 像点击，悬浮触发函数都是异步的，所以需要立即执行函数，否则会出现问题
				(function(i) {
					setTimeout(function() {
						console.log(lis[i].innerHTML);
					}, 3000)
				})(i);
			}
```



**案例三**：计算打车价格



```javascript
	//闭包应用三：计算打车价格
			//打车起步价13（3公里内），之后每多一公里增加五元，用户输入公里数就可以计算打车价格
			//如果有拥堵情况，总价格多收取十块钱拥堵费
			var car = (function(){
				var start = 13;	// 起步价
				var total = 0;	//总价
				return {
					//正常总价
					price:function(n){
						if (n<=3){
							total = start;
						}else{
							total = start + (n - 3) * 5;
						}
						return total;
					},
					//拥堵之后的费用		
					yd:function(flag){
						return flag ? total + 10 : total;
						// 如果flag为true则total加10否则total不变
					}			
				}
			})();
			console.log(car.price(5));	//因为闭包把值存储在里面了 并没有销毁，所以这里23不会被销毁，所以下面会输出33
			console.log(car.yd(true));
```

### 递归

如果一个函数在内部可以调用其本身，那么这个函数就是递归函数

简单理解：函数内部自己调用自己，这个函数就是递归函数

```javascript
var num = 1;
function fn(){		//无限套娃
	console.log('我要打印6句话');
    if(num == 6){
		return;		//递归里面必须添加退出条件，否则会变成死递归
    }
    num++;
    fn();
}
fn();
```

递归函数的作用和循环效果一样

由于递归很容易发生栈溢出错误，所以必须要加退出条件return

（目前貌似有公司禁止使用）

##### 递归案例

利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 *...n

```
function fn(n){
if (n == 1){
	return 1;
	}
	return n * fn(n-1);
}
console.log(fn(3));
```

2.利用递归函数求斐波那契数列（兔子序列）1, 1 , 2, 3 , 5, 8 ,13 ,21 ...

用户输入一个数子n就可以求出这个数字对应的兔子序列值

我们只需要知道用户输入的n 的前面两项就可以计算出n对应的值

```
function fb(n){
	if (n === 1||n === 2){
		return 1;
	}
	return fb(n-1)+ fb(n-2);
}
console.log(fb(3));
```

3.利用递归遍历数据

```JavaScript
var data = [{
			id:1,
			name:'家电',
			goods:[{
				id:11,
				gname:'冰箱',
				goods:[
					{
					id:111,
					gname:'海尔'
				},
				{
					id:112,
					gname:'美的'
				},					
				]
			},
			{
				id:12,
				gname:'洗衣机'
			}]
			},
			{
				id:2,
				name:'服饰'
			}
		];
		// 我们想要做输入id号，就可以返回的数据对象
		//1.利用 foreach 去遍历里面的每一个对象
		function getID(json,id){
			json.forEach(function(item){
				if (item.id == id){
					console.log(item);
					o = item;
					//我们想要得到里层的数据 11 12可以利用递归函数
					//里面应该有goods这个数组，并且数组的长度不为0
				}else if(item.goods && item.goods.length>0){
					o = getID(item.goods,id);
				}
			
			});
			return o;
		}
		getID(data,1);
		getID(data,112);
```

#### 浅拷贝和深拷贝

##### 浅拷贝

浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用

```javascript
	var obj = {
			id: 1,
			name: 'andy',
			msg:{
				age: 18
			}
		};
		var o ={};
		for(var k in obj){
			//k是属性名，obj[k]是属性值
			o[k] = obj[k];	//相当于o.k
			
		}
		console.log(o);
		o.msg.age = 20;//测试更改o的msg会不会影响obj的
		console.log(obj);
//结果：o和obj的age都是20
```

这就是浅拷贝。但这样拷贝，msg属于深层次对象级别，虽然能拷贝过来，但是拷贝的是地址，也就是o的msg和obj的msg指向的是同一个数据，此时若修改o的msg也会影响obj里面的msg，如上面测试结果。但是如果更改最外层的数据（例如name），修改o不会影响obj

![1](D:\web前端\JavaScript note\js进阶\img\11.15\1.png)



Object.assign(target,...sources) 是es6新增方法可以实现浅拷贝（语法糖）

target:接受的对象

sources：被拷贝对象

也就是把sources拷贝给target

```javascript
Object.assign(o,obj);
console.log(o);
// 此段代码和上面代码的for循环起到了相同作用
```

##### 深拷贝

深拷贝拷贝多层，每一级别的数据都会拷贝。在这里obj中的msg又是一个对象，所以会新开辟一个空间，深拷贝会把新开辟的空间重新复制一份新的空间，把拷贝完的空间再给o，这样两个空间互不相干，故而改变其中一个不会影响另外一个

![2](D:\web前端\JavaScript note\js进阶\img\11.15\2.png)

**代码案例：**

```javascript
	var obj = {
				id: 1,
				name: 'andy',		//简单类型
				msg: {
					age: 18			//对象类型
				},
				color: ['pink', 'red']	//数组类型
			};
			var o = {};
```

```javascript
	//封装函数
			function deepCopy(newobj, oldobj) {
				for (var k in oldobj) {
					//判断我们的属性值属于哪种数据类型，是简单还是复杂
					//1.获取属性值 oldobj[k]
					var item = oldobj[k];
					//2.判断这个值是否是数组
					if (item instanceof Array) {
						newobj[k] = [];
						deepCopy(newobj[k], item);
					} else if (item instanceof Object) {
						//3.判断这个值是否是对象
						newobj[k] = {};
						deepCopy(newobj[k], item)
					} else {
						//4.属于简单数据类型
						newobj[k] = item;
					}
				}
			}
			deepCopy(o, obj);
			console.log(o);
			o.msg.age = 20;
			console.log(obj);
```

**注：**因为数组也属于Object，所以判断是否是array类型要放在判断是否是对象类型之前

**测试结果：**

![3](D:\web前端\JavaScript note\js进阶\img\11.15\3.png)

obj成功拷贝，并且证实了改变o.ms



### 正则表达式

**正则表达式**是用于匹配字符串中字符组合的模式。在JS中，正则表达式也是对象。

正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如**验证表单**：用户名表单只能输入英文字母、数字或者下划线，昵称输入框可以输入中文（匹配）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词，或者从字符串中获取我们想要的特定部分（提取）等。

#### 创建正则表达式

1.利用RegExp对象来创建 正则表达式

```js
var regexp = new RegExp(/表达式/);
```

2.利用字面量创建正则表达式

```
var rg = /123/;
```

**注**:正则表达式里面不需要加引号,不管是数字型还是字符串型

#### 测试正则表达式test

test()正则对象方法,用于检测字符串是否符合该规则,该对象 会返回true或false,其参数是测试字符串

```js
regexobj.test(str)	//这句话是检测str文本是否符合正则表达式规范
```

其中regexObj 是写的正则表达式

str 是我们要测试的文本

#### 正则表达式的组成

一个正则表达式可以由简单的字符组成,如/abc/,也可以是简单和特殊字符的组合,比如/ab*c/.其中特殊字符也被称为元字符,在正则表达式中是具有特殊意义的专用符号.如:^ ,$,+等.

##### 边界符

正则表达式中

边界符用来提示字符所处的位置,主要有两个字符

| 边界符 | 说明                         |
| :----- | ---------------------------- |
| ^      | 表示匹配行首的文本(以谁开始) |
| $      | 表示匹配行尾的文本(以谁结束) |

```js
var rg = /abc/;	//只要包含有abc这个字符串的返回的都是true
console.log(rg.test('abc'));	//true
console.log(rg.test('aabc'));	//true
```

```js
var reg = /^abc/;		// 以abc开头的就是true
console.log(rg.test('abc'));	//返回true
console.log(rg.test('abcd'));	//返回true
console.log(rg.test('aabc'));	//返回false
```

```js
var reg1 = /^abc$/;	// 精确匹配 代表必须是abc这个字符串
```

如果^和$在一起,代表精确匹配

##### 字符类

[]表示有一系列字符可供选择，只要匹配其中一个就可以了

```js
var rg =  /[abc]/;	//只要包含有a或者有b或者含有c就返回true
console.log(rg.test('andy')); //true

var rg = /^[abc]$/; //三选一，只有是a或b或c 这三个字母才返回true
console.log(rg.test('a')); 	// true
console.log(rg.test('b')); 	//true
console.log(rg.test('c')); 	//true
console.log(rg.test('abc')); 	//false
```

[-] 方括号内部范围符-

```js
var rg1 = /^[a-z]$/; //26个英文字母任何一个字母且只有一个返回true
console.log(rg.test('a')); 	//true
console.log(rg.test('z')); //true
console.log(rg.test('A)); //false
```

字符组合

```js
var reg = /^[a-zA-Z0-9_-]$/; //26个英文字母（大小写）任何一个字母以及任何一个数字或者 -和 _ 且仅有一个
console.log(reg.test(8));//true
console.log(reg.test(-));//true
```

[^] 方括号内部取反符^

前面的^在[]外，是边界符，但是在[]里就不是了,千万和边界符^弄混

```js
var reg1 = /^[^a-zA-Z0-9_-]$/; //^在[]里表示取反  
//代表里面不能有a-z,A-Z,0-9,-,_
console.log('!'); //true
```

##### 量词符

量词符 用来设定某个模式出现的次数

| 量词  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n次到m次     |

**量词***

```js
var reg = /^a*$/;	//重复零次或者多次都是true（不能出现别的字符）
console.log(reg.test(''));		//true
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//true
```

**量词+**

````js
var reg = /^a+$/;	//重复一次或者多次都是true（不能出现别的字符）
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//true
````

**量词？**

```
var reg = /^a?$/;	//重复一次或者0次都是true（不能出现别的字符）
console.log(reg.test(''));		//true
console.log(reg.test('a'));		//true
console.log(reg.test('aaa'));	//false
```

**量词{n}**

```js
//{3 }就是重复三次
var reg = /^a{3}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true

//{3, }就是大于等于3次
var reg = /^a{3,}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true
console.log(reg.test('aaaaa'));	//true
```

**量词{n,m}**

```js
//{3,6}就是大于等于3次且小于等于6次
var reg = /^a{3,6}$/;
console.log(reg.test(''));		//false
console.log(reg.test('a'));		//false
console.log(reg.test('aaa'));	//true
console.log(reg.test('aaaaa'));	//true
```

```js
var reg = /^[a-zA-Z0-9_-]{6,16}$/;
//用户只能输入英文字母数字以及-_并且为6-16位
//{6,16} 中间不要有空格
console.log(reg.test('andy_red08')); //true
console.log(reg.test('andy!007')); //false
```

##### 案例

**用户名验证**

功能：1.如果用户名输入合法，就提示用户名合法且颜色为绿色

​			2.如果用户名不合法，后面提示信息为不合法且颜色为红色

​			3.当表单失去焦点就开始验证

​			4.如果符合规范，就在后面的span标签添加right类

​			5.如果不符合规范，就在后面的span标签添加wrong类

**代码：**

```html
<input type="text" class = "uname"><span>请输入用户名</span>
		<script>
		var reg = /^[a-zA-Z0-9-_]{6,16}$/;
		var uname = document.querySelector('.uname');
		var span = document.querySelector('span');
		uname.onblur = function(){
			if (reg.test(this.value)){
				span.className = 'right';
				span.innerHTML = "用户名格式正确";
			}else{
				span.className = 'wrong';
				span.innerHTML = "用户名格式错误";
			}
		}
		</script>
```

##### 括号总结

中括号[],字符集合，匹配方括号中的任意字符

```js
var reg = /^[abc]$/;
//a||b||c
```

大括号{} 量词符，里面表示重复次数

```js
var reg = /^abc{3}$/; //它只是让c重复三次
console.log(reg.test('abcabcabc'));
//false
console.log(reg.test('abccc'));
//true
```

小括号表示优先级(把小括号里面的看成一个整体)

```js
var reg = /^(abc){3}$/;//它是让abc重复三次
console.log(reg.test('abcabcabc'));
//true
console.log(reg.test('abccc'));
//false;
```

##### 预定义类

| 预定义类 | 说明                                                       |
| -------- | ---------------------------------------------------------- |
| \d       | 匹配0-9之间的任一数字，相当于[0-9]                         |
| \D       | 匹配所有0-9以外的字符，相当于[ ^0-9]                       |
| \w       | 匹配任意的字母，数字和下划线，相当于[A-Za-z0-9_]           |
| \W       | 除所有字i母，数字和下划线意外的字符，相当于[ ^A-Za-z0-9_]  |
| \s       | 匹配空格(包括换行符、制表符、空格符等)，相当于[\t\r\n\v\f] |
| \S       | 匹配非空格的字符，相当于[ ^\t\r\n\v\f]                     |

座机号码验证：两种格式，一个是 010-12345678或者 0110-1234567

```js
//正则里面的或 |
//var reg = /^\d{3}-\d{8}|\d{4}-\d{7}$/;
var reg = /^\d{3,4}-\d{7,8}$/;
```

##### 正则替换

**replace替换**

replace方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式,返回值是一个替换完毕的新字符串

```js
//替换
var str = 'andy和red';
var newstr = str.replace(/andy/,'baby');
//把andy替换成baby
```

**敏感词替换案例**

```html
<textarea name = "" id="mes"></textarea><button>提交</button>
		<div></div>
		<script>
		var text = document.querySelector('textarea');
		var btn = document.querySelector('button');
		var div = document.querySelector('div');
		btn.onclick = function(){
			div.innerHTML = text.value.replace(/激情/,'**');
		}
		</script>
```

但这样只能过滤第一个敏感词，不能过滤所有的

如图

![1](D:\web前端\JavaScript note\js进阶\img\11.16\1.png)

##### 正则表达式参数

```
/表达式/[switch]
```

switch(也称为修饰符)按照什么样的模式来匹配，有三种值：

- g：全局匹配
- i：忽略大小写
- gi：全局匹配且忽略大小写

所以只需要改动一处

```js
div.innerHTML = text.value.replace(/激情/g,'**');
```

这样就可以实现全局匹配了

想要实现多个敏感词只需要用|，如

```js
div.innerHTML = text.value.replace(/激情|xx|xxx/g,'**');
```

就可以实现

# ES6



## let关键字

ES6中新增的用于声明变量的关键字

- let声明的变量旨在所处于的块级有效

```js
if(true){
let a = 10;
    if(true){
		let c = 30;
    }
    console.log(c);	//c is not defined
}
console.log(a); // a is not defined
```

在一个大括号中，使用let关键字声明的变量才具有块级作用域

var关键字是不具备这个特点的

```js
for (let i = 0;i < 2;i++){

}
cosole.log(i); 	// i is not defined

for (var i = 0;i < 2;i++){

}
cosole.log(i); 	// 2
```

拥有块级作用域的变量能带来的好处：防止循环变量变成全局变量

- 不存在变量提升

```js
console.log(a);
let a = 100;
```

- 暂时性死区特性

```js
var tmp = 123;
if(true){
	tmp = 'abc';
	let tmp;
}
```

虽然if语句外有同名变量，但是和块级作用域中的tmp是毫无关系的，它们之间不会相互影响，let定义的变量和块级这个整体进行了绑定，所以在变量声明的前面使用变量，会报错，报变量没有定义的错，这种特性叫暂时性死区。

### 经典面试题

```js
var arr = [];
for (var i = 0;i < 2;i++){
		arr[i] = function(){
			console.log(i);
	}
}
// 注意：for循环只是往arr数组中添加函数而不是执行
arr[0]();	//由于arr[i]的值就是函数所以可以直接后面加()调用
arr[1]();
```

由于函数执行时，循环早就结束了，所以i的值是不满足循环条件的值。所以函数执行时输出的i值是2。由于数组中存储的两个函数在执行时输出的都是`全局变量i`,所以两次输出结果都是一样的，都是2。当前代码的关键点在于，变量i是全局的，函数执行时输出的都是全局作用域下的i值

![1](D:\web前端\ES6 note\img\1.png)

若把var改成let

```js
var arr = [];
for (let i = 0;i < 2;i++){
		arr[i] = function(){
			console.log(i);
	}
}
// 注意：for循环只是往arr数组中添加函数而不是执行
arr[0]();	//由于arr[i]的值就是函数所以可以直接后面加()调用
arr[1]();
```

由于使用let声明的变量，具有块级作用域，循环又执行两次。所以循环两次后产生了两个块级作用域，产生的两个块级作用域中都有自己的变量i，这是两个变量，是互不影响的，因为它们处于两个不同的块级作用域。循环结束后，数组中依然存储两个函数，函数执行时，函数内部依旧没有自己的变量i，还是要向上一级作用域中查找，而它们的上一级作用域实际上就是循环产生的块级作用域，所以两个函数执行时要分别去自己对应的块级作用域中查找变量i的值，所以数组中的第一个函数执行时，输出的是第一个块级作用域中变量i的值，就是0，第二个输出的是第二个块级作用域的值，就是1。

**关键点：**每一次循环都会产生一个块级作用域，每个块级作用域的变量i都是不同的。函数执行时，输出的是自己上一级作用域下变量i的值，也就是循环产生的块级作用域下i的值。

## const关键字

作用：声明常量。即为内存地址不能变化的量。

- 具有块级作用域

```js
if (true){
	const a = 10;
    if (true){
    	const a = 20;
        console.log(a);	// 20
    }
    console.log(a);		//10
}
console.log(a);	//a is not defined
```

- 声明常量时必须赋值

```js
const PI; // Missing initializer in const declaration
```

- 常量赋值后，值通常不能修改

```js
const PI = 3.14
PI = 100; //Assignment to constant variable.
```

```js
const ary = [100,200];
ary[0] = 'a';
ary[1] = 'b';
console.log(ary); // ['a','b'];
//这种更改操作是可以的，因为这个操作没有更改ary常量在内存中的存储地址
ary = ['a','b']; //Assignment to constant variable.
//这种操作不被允许，因为这个操作改变了ary常量在内存中的存储地址
```

## let、const、var的区别

1.使用**var**声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。

2.使用**let**声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。

3.使用**const**声明的是常量，在后面出现的代码中不能再修改该常量的值。

|     var      |      let       |     const      |
| :----------: | :------------: | :------------: |
| 函数级作用域 |   块级作用域   |   块级作用域   |
|   变量提升   | 不存在变量提升 | 不存在变量提升 |
|   值可修改   |    值可更改    |   值不可更改   |

## 解构赋值

ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构

### 数组解构

数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋值给变量

```js
let [a,b,c] = [1,2,3];
console.log(a);
console.log(b);
console.log(c);
```

如果解构不成功(没有对应的值)，变量的值为undefined

```js
let ary = [1,2,3];
let [a,b,c,d,e] = ary;
console.log(c);
console.log(d);	//undefined
console.log(e); //undefined
```

### 对象解构

对象解构允许我们使用变量的名字匹配对象的属性，匹配成功将对象属性的值赋值给变量

```js
let person = {name:'zhangsan',age:20};
let { name,age } = person;
console.log(name); //'zhangsan'
console.log(age);	//20
```

另一种写法：

这种写法支持变量的名字和对象中属性的名字不一样

```js
let { name:myName,age:myAge } = person;	//myName,myAge属于别名
console.log(myName);
console.log(myAge);
```

在解构语法中，冒号左边的name只用于属性匹配，冒号右边的myName才是真的变量

## 箭头函数

ES6中新增的定义函数的方式，箭头函数是用来简化函数定义语法的

```js
() => {}
```

小括号中放置形参，大括号里面代表函数体

通常，我们会将箭头函数赋值给一个变量，变量名字就是函数名字，通过变量名字调用函数就可以了

```js
const fn = () => {}
```

若函数体中只有一句代码，且代码执行结果就是返回值，可以省略大括号

```js
function sum(num1,num2){
	return num1 + num2;
}
//等同于
const sum = (num1,num2) => num1 + num2;
```

如果形参只有一个，可以省略形参外面的小括号

```js
function fn(v){
	alert(v);
}

const fn = v => {
	alert(v);
}
```

箭头函数不绑定this，没有自己的this关键字，箭头函数中的this，指向的是**函数定义位置的上下文this**，也就是说，this关键字指向箭头函数定义位置中的this。

```js
const obj = { name:'zhangsan'}
function fn(){
	console.log(this);
	return () => {
		console.log(this)
	}
}
const resfn = fn.call(obj);
resfn();
```

调用fn函数并通过call将fn()的this指向obj，由于箭头函数处于fn中，所以它里面的this指向的也是fn()指向的this，即也为obj。

### 箭头函数面试题

```js
var obj = {
	age:20,
	say:() => {
		alert(this.age)
	}
}
obj.say();		// alert(undefined)
```

obj是一个对象，不能产生作用域，实际上这个箭头函数被定义在了全局作用域下，所以在调用say方法时，this指向的是window，而window下面没有age属性，所以弹出了undefined

在window对象下面添加一个age属性，证明obj.say方法弹出的是window对象的age属性

```js
var age = 100;
var obj = {
	age:20,
	say:() => {
		alert(this.age)
	}
}
obj.say();		// alert(100)
```

## 剩余参数

当函数实参个数大于形参个数时，可以将剩余的实参放入一个数组中

```js
function sum(first, ...args){
	console.log(first);	//10
	console.log(args);	//[20,30]
}
sum(10,20,30);

const sum = (...args) => {
    	let total = 0;
    	args.forEach(item => total+=item;)
    return total;
};
sum(10,20);
sum(10,20,30);
```

### 剩余参数和解构配合使用

```js
let ary = ['wang','zhang','li'];
let[s1,...s2] = ary;
console.log(s1); //wang
console.log(s2); //array(2)=['zhang','li'];
```

## ES6的内置对象扩展

### Array的扩展方法

扩展运算符可以将数组或者对象转为用逗号分隔的参数序列

```js
let ary = [1,2,3];
...ary //1,2,3
console.log(...ary); //1 2 3
console.log(1，2，3); //1 2 3
```

因为逗号被当作console.log方法的参数分割符了，所以输出结果中是没有逗号的

扩展运算符可以将数组拆分成以逗号分隔的参数序列

#### 合并数组

扩展运算符可以应用于合并数组

```js
let ary1 = [1,2,3];
let ary2 = [3,4,5];
let ary3 = [...ary1,...ary2];
```

ES5用concat实现拼接

第二种方法 push方法

```js
ary1.push(...ary2); //将ary2追加到ary1后，若拼接多个用逗号分隔
```

#### 伪数组转换

将伪数组转换成真正的数组

```js
var odivs = document.getElementByTagName('div');
console.log(odivs);
var ary = [...odivs];
arr.push('a');
```

**_为什么要把伪数组转换成真正的数组呢？_**

伪数组转换成真正的数组后，就可以调用数组对象下面的方法了，比如push方法

##### 构造函数方法

**Array.from()**

将类数组或可遍历对象转化为真正的数组

```js
var arrayLike = {
"0":"zhang",
"1":"wang",
"2":"li",
"length":3
}
var ary = Array.from(arrayLike);
console.log(arrayLike);
console.log(ary);
```

打印后二者区别

![2](D:\web前端\ES6 note\img\2.png)

方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组

```js
let arrayLike = {
"0":1,
"1":2,
"length":2
}
let newAry = Array.from(arrayLike,(item) =>{
    return item *2;
})
//可省略成以下格式
let newAry = Array.from(arrayLike,item=>item *2);
```

#### 实例方法find()

用于找出第一个符合条件的数组成员，如果没有找到返回undefined

```js
let ary = [
{
	id:1,
	name:'zhang'
},
{
	id:2,
	name:'li'
}
];
//查找数组中id为2的那个对象
let target = ary.find(item => item.id ==2);
```

#### 实例方法findIndex()

用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1

```js
let ary = [1,5,10,16];
let index = ary.findIndex(item => item > 15);
```

#### 实例方法includes()

表示某个数组是否包含给定的值，返回布尔值

```js
[1,2,3].includes(2) //true
[1,2,3].includes(4) //false
```

### String的扩展方法

#### 模板字符串

ES6新增的创建字符串的方式，使用反引号定义

模板字符串中可以解析变量

```js
let name = `zhang`;
let sayhello = `hello,my name is ${name}`;
console.log(sayhello);
```

模板字符串中可以换行

```js
let result = {
	name:'zhang',
	age:20,
	sex:'男'
}
let html = `
		<div>
		<span>${result.name}</span>
		<span>${result.age}</span>
		<span>${result.sex}</span>
		</div>
		`;
console.log(html);
```

![3](D:\web前端\ES6 note\img\3.png)

模板字符串中可以**调用函数**

```js
const fn = ()=>{
	return '我是fn函数'
}
let html = `我是模板字符串${fn()}`;
console.log(html);
```

#### 实例方法startsWith()和endsWith()

- startsWith(): 表示参数字符串是否在原字符串的头部，返回布尔值
- endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值

```js
let str = 'hello world!';
str.startsWith('hello'); //true
str.endsWith('!'); //true
```

#### 实例方法repeat()

repeat方法表示将原字符串重复n次，返回一个新字符串

```js
console.log("y".repeat(5));
```

### 对象方法扩展

#### Object.is() 

判断两个值是否完全相等

```
console.log(Object.is(120,120));	
//作用和===很像 但是判断两个NAN是否相等时，is方法返回的true但是全等号返回的是false
```

#### Objcet.assign() 

对象的合并

```js
const conf1 = {
	host:'localhost',
	port:3306,
	name:'root',
};
const conf2 = {
	host:'localhost3',
	port:33064,
	name:'root3',
}
Object.assign(conf1,conf2);
//取并集，一样的属性第二个覆盖第一个
```

#### Object.setPrototypeOf() 

设置原型对象

```js
const school = {
	name:'zhang'
}
const cities = {
	xiaoqu:['beijing','shanghai']
}
Object.setPrototypeOf(school.cities);
console.log(Object.getPrototypeOf(school));	//获取原型对象
```



### Set数据结构

ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值

Set本身是一个构造函数，用来生成Set数据结构

```js
const s1 = new Set();
console.log(s1.size);	// 0
const s2 = new Set(["a","b"]);
console.log(s2.size); // 2
```

**利用Set结构可以做数组去重**

因为set集合具有唯一性，它会自动将重复的值去除

```js
const s3 = new Set(["a","a","b","b"]);
console.log(s3.size); //2    去重了
const ary = [...s3];	//通过扩展运算符将set结构转换成以逗号分隔的零散量
console.log(ary);
```

**求交集**

```js
let arr = [1,2,3,4,5,4,3,2];
let arr2 = [4,5,6,7];
let result = [...new Set(arr)].filter(item=>new Set(arr2).has(item));
```

**求并集**

```js
let result = [...new Set([...arr,...arr2])];
```

**求差集**

```js
let diff = [...new Set(arr)].filter(item=>!new Set(arr2).has(item));
```



#### Set实例方法

- add(value):添加某个值，返回Set结构本身
- delete(value):删除某个值，返回一个布尔值表示删除是否成功
- has(value):返回一个布尔值，表示该值是否为Set的成员
- clear():清除所有成员，没有返回值

```js
const s = new Set();
s.add(1).add(2).add(3);
s.delete(2);
s.has(2);
s.clear();
console.log(s.size()); // 0
```

#### 遍历

Set结构的实例与数组一样，也拥有forEach()方法，用于对每个成员执行某种操作，没有返回值

```js
const s = new Set(['a','b','c']);
s.forEach((item)=>{
	console.log(item);
})
```

### Symbol数据类型

#### Symbol创建

ES6引入了一种新的原始数据类型**Symbol**，表示独一无二的值，是JS语言的第七种数据类型，是一种类似于字符串的数据类型。

- Symbol的值是唯一的，用来解决命名冲突的问题
- Sybol的值不能与其它数据进行与逆行
- Symbol定义的对象属性不能使用for...in...循环遍历，但是可以使用**Reflect.ownKeys**来获取对象的所有键名

```js
let s = Symbol('zhang');
let s2 = Symbol('zhang');
console.log(s2 === s3);	//false,它们的地址是不一样的
//创建Symbol的第二种方式
// 全局符号注册表的方式
let s3 = Symbol.for('zhang');
let s4 = Symbol.for('zhang');
console.log(s3 === s4); //true
```

**JS的几种数据类型：**

undefined , string , symbol , object, null, number, boolean

#### Symbol使用场景

来给对象添加属性和方法，表示独一无二的

当直接给对象中添加方法中，有没有这个方法不确定，所以有风险，需要看结构再决定命名。用Symbol会变得更简单安全。

```js
//向对象中添加方法 up down
let game = {
	...
}
//声明一个对象
let methods = {
	up:Symbol(),
	down:Symbol()
}
game[methods.up] = function(){
    console.log('我是上');
}
game[methods.down] = function(){
    console.log('我是下');
}
game[methods.up](); 	// 我是上
//另一种方法
let youxi = {
    name:"kill",
    [Symbol('say')]:function(){
        console.log("shuo")
    },
    [Symbol('zibao')]:function(){
        console.log('zibao');
    }
}
```

最大用处：内置符号 （**待补充**）

### 迭代器

迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作。ES6创造了一种新的遍历命令for...of...循环，Iterator接口主要供for...of消费

原生具备iterator接口的数据（可用for of遍历）

- Array
- Arguments
- Set
- Map
- String
- TypedArray
- NodeList

```js
const xiyou = ['唐僧','孙悟空','猪八戒'];
//使用for...of遍历数组
for(let v in xiyou){
	console.log(v); // 0 1 2 输出的是键名
}
for(let v of xiyou){
	console.log(v); //唐僧，孙悟空，猪八戒 输出的是键值
}
```

只要对象里有Symbol(Symbol.interator)属性，就可以使用for...of...遍历数组

#### 工作原理

1. 创建一个指针对象，指向当前数据结构的起始位置
2. 第一次调用对象的next方法，指针自动指向数据结构的第一个成员
3. 接下来不断调用next方法，指针一直在往后移动，直到指向最后一个成员
4. 每调用next方法返回一个包含value和done属性的对象

**注：**需要自定义遍历数据的时候，要想到迭代器

#### 迭代器的应用

```js
const banji = {
	name:"一班",
	stus:[
	'xiaoming',
	'xiaoli',
	'xiaohong',
	'xiaomei'
	]
}
//遍历这个对象
for(let v of banji){
	console.log(v);	//error!banji is not iterable
}
```

object没有iterator,所以不支持for...of,要给对象写一个接口才可以使用for...of遍历

```js
//相当于迭代器原理
[Symbol.iterator](){
	let index = 0;
	let that = this;	//也可以使用箭头函数
	return {
	next:function(){
		if(index<that.stus.length){
			const result =  {value:that.stus[index],done:false};
		//下标自增
		index++;
		return result;
		}else{
			return {value:undefined,done:true};
		}
	}
	};
}
```

### 生成器

生成器函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同

生成器其实就是一个特殊的函数，之前的异步编程是利用纯回调函数

```js
function *gen(){
	console.log("hello gennerator")
}
let iterator = gen();
iterator.next();
```

声明和执行都比较特殊

可以出现`yield`语句，相当于函数代码的分隔符，把函数代码切割成几块

```js
function *gen(){
	console.log("111");
    yield'第一个';
    console.log("222");
    yield'第二个';
    console.log("333");
    yield'第三个';
    console.log("444");
    yield'第四个';
}
let iterator = gen();
iterator.next();
iterator.next();
iterator.next();
iterator.next();
```

执行结果

![6](D:\web前端\ES6 note\img\6.png)

```js
function *gen(){
    yield'第一个';
    yield'第二个';
    yield'第三个';
}
for(let v of gen()){
    console.log(v);
}
//输出结果为yield后面的值：
//第一个
//第二个
//第三个
```

```js
function *gen(){
    yield'第一个';
    yield'第二个';
    yield'第三个';
}
let iterator = gen();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
```

结果：

![7](D:\web前端\ES6 note\img\7.png)

#### 生成器函数参数

```js
function *gen(arg){
	console.log(arg);
	let one = yield 111;
    console.log(one);
	let two = yield 222;
    console.log(two);
	let three = yield 333;
    console.log(three);
}
//执行获取迭代器对象
let iterator = gen('AAA');
//next方法可以传入实参
console.log(iterator.next());
console.log(iterator.next('BBB'));
//第二次next方法传入的参数将作为第一个yield语句整体返回结果
console.log(iterator.next('CCC'));
////第三次next方法传入的参数将作为第二个yield语句整体返回结果
console.log(iterator.next('DDD'));
////第四次next方法传入的参数将作为第三个yield语句整体返回结果
```

![8](D:\web前端\ES6 note\img\8.png)

#### 生成函数实例

演示生成器函数在异步编程中的表现

```js
//1s后控制台输出111，2s后输出222，3s后输出333
//但这样会形成回调地狱
setTimeout(()=>{
    console.log(111);
    	setTimeout(()=>{
   		console.log(222);
   			setTimeout(()=>{
   			console.log(333); 
		},3000);
	},2000);
},1000);
```

通过生成器函数实现

```js
function one(){
	setTimeout(()=>{
		console.log(111);
        iterator.next();
	},1000)
}
function two(){
	setTimeout(()=>{
		console.log(222);
        iterator.next();
	},2000)
}
function three(){
	setTimeout(()=>{
		console.log(333);
        iterator.next();
	},3000)
}
function * gen*(){
    yield one();
    yield two();
    yield three();
}
//调用生成器函数
let iterator = gen();
iterator.next();
```

**生成器函数实例二**

模拟获取 用户数据  订单数据  商品数据

每隔1s依次打印

```js
function getUsers(){
	setTimeout(()=>{
		let data = '用户数据';
        iterator.next(data);
	},1000);
}
function getOrders(){
	setTimeout(()=>{
		let data = '订单数据';
         iterator.next(data);
	},1000);
}
function getGoods(){
	setTimeout(()=>{
		let data = '商品数据';
        iterator.next(data);
	},1000);
}
function *gen(){
	let users = yield getUsers();
    console.log(users);
    let orders = yield getOrders();
    console.log(orders);
  	let goods = yield getGoods();
    console.log(goods)
}
//调用生成器函数
let iterator = gen();
iterator.next();
```

这就是生成器函数在异步任务的一个表现

### Promise

ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果

```js
//实例化Promise对象
const p = new Promise(function(resolve,reject){
	setTimeout(function(){
	// 异步操作
	let data = '数据库中用户数据';
        //调用resolve函数：成功
        resolve(data);
        //调用完resolve之后，这个promise对象的状态就会变成成功
        //对象有三个状态，一个是初始化，一个是失败，一个是成功
    
        //调用reject：失败
    let err = '数据读取失败';
    reject(err);
	},1000);
});
//调用promise对象的then方法
p.then(function(value){
	//状态为成功调用这个
    console.log(value);
},function(reason){
    //状态为失败调这个
    console.errpr(reason);
})
```

通过这个方式把异步任务封装在了Promise对象里面，而且通过resolve和reject这两个函数来改变它的状态，改变之后来调用then方法里面的回调，倘若成功调用里面的第一个回调函数，若是失败调用第二个回调函数

#### Promise案例

1.使用Promise封装读取文件

不用Promise实现：

**注：**使用node.js需要下载相关环境，且在js文件中打开终端，输入node 文件路径，才能运行，具体fs模块相关，在async模块有解释

```js
//这里用到了node.js的相关知识
const fs = require('fs');
//引入fs模块
//调用方法读取文件
fs.readFile('./为学.md',(err,data)=>{
	//如果失败则抛出错误
	if(err) throw err;
	//如果没有出错，则输出内容
	console.log(data.toString());
})
```

使用Promise实现：

```js
//这里用到了node.js的相关知识
const fs = require('fs');
const p = new Promise(function(resolve,reject){
	fs.readFile('./为学.md',(err,data)=>{
		//判断如果失败
		if(err) reject(err);
		//如果成功
		resolve(data);
	});
});
p.then(function(value){
	console.log(value.toString());
	
},function(reason){
	console.log("读取失败");
});
```

#### Promise封装ajax

不用Promise实现：

```js
	//接口地址: https://api.apiopen.top/getJoke
		//创建对象
		const xhr = new XMLHttpRequest();
		//初始化
		xhr.open("GET","https://api.apiopen.top/getJoke");
		//发送
		xhr.send();
		//绑定事件，处理响应结果
		xhr.onreadystatechange =  function(){
			//判断
			if(xhr.readyState === 4){	// 等于4说明了所有的响应体都已经回来了
				//判断响应状态码 200-299
				if (xhr.status >=200 && xhr.status < 300){
					//表示成功
					console.log(xhr.response);
				}else{
					//如果失败
					console.error(xhr.status);
				}
			}
		}
```

使用Promise封装：

```js
		const p = new Promise((resolve,reject)=>{
			
		//创建对象
		const xhr = new XMLHttpRequest();
		//初始化
		xhr.open("GET","https://api.apiopen.top/getJoke");
		//发送
		xhr.send();
		//绑定事件，处理响应结果
		xhr.onreadystatechange =  function(){
			//判断
			if(xhr.readyState === 4){	// 等于4说明了所有的响应体都已经回来了
				//判断响应状态码 200-299
				if (xhr.status >=200 && xhr.status < 300){
					//表示成功
					resolve(xhr.response);
				}else{
					//如果失败
					reject(xhr.status);
				}
			}
		}
		})
		//指定回调
		p.then(function(value){
			console.log(value);
		},function(reason){
			console.error(reason);
		});
```

#### then方法

```js
const result = p.then(value => {
			console.log(value)
			//1.非promise类型的属性
			//return '成功的值';
			//2.是promise对象
			//return new Promise((resolve,reject)=>{
			//	resolve('ok');
			//});
			//3.抛出错误
			//throw new Error('出错啦'); 也是返回错误状态
		},reason=>{
			console.warn(reason);
		})
		console.log(result);
		//因为回调函数有延迟，所以先打印出result再打印出"出错啦"
		
		//链式调用,可以杜绝回调地狱
		p.then(value=>{
			
		}).then(value=>{
			
		})
```

#### Promise实现读取多个文件

原始方式

```js
//原始方式 引入fs模块
const fs = require("fs");

fs.readFile('./为学.md',(err,data1)=>{
	fs.readFile('./观书.md',(err,data2)=>{
		fs.readFile('./劝学.md',(err,data3)=>{
			let result = data1 +data2+data3;
			console.log(result);
		});
	});
});
```

使用Promise实现

```js
//使用promise实现
const p = new Promise((resolve,reject)=>{
	fs.readFile('./为学.md',(err,data)=>{
		resolve(data);
	});
});
p.then(value=>{
	return new Promise((resolve,reject)=>{
		fs.readFile('./观书.md',(err,data)=>{
		resolve([value,data]);
	});
	})
}).then(value => {
	return new Promise((resolve,reject)=>{
		fs.readFile('./劝学.md',(err,data)=>{
		//压入
		value.push(data);
		resolve(value)
	});
	})
}).then(value=>{
	console.log(value.join('\r\n'));
});
```

#### Promise对象catch方法

用来指定Promise对象失败的一个回调

```js
	const p = new Promise((resolve,reject)=>{
			setTimeout(()=>{
				//设置p对象的状态为失败，并设置失败的值
				reject("error!");
			},1000)
		});
	
		// p.then(function(value){},function(reason){
		// 	console.error(reason);
		// });
		p.catch(function(reason){
			console.warn(reason);
		})
//这个与注释部分达成的效果一样
```

### Map数据结构

ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map也实现了iterator接口，所以可以使用**扩展运算符**和**for...of...**进行遍历

- size：返回Map的元素个数
- set：增加一个新元素，返回当前Map
- get：返回键名对象的键值
- has：检测Map里是否包含某个元素。返回bool值
- clear清空集合，返回undefined

```js
let m = new Map();
m.set('name','zhang');
m.set('change',function(){
	console.log('改变');
});
```

第一个键名：name，值为zhang

再增加一个键

```js
let key = {
	school:'lu'
};
m.set(key,['beijing','shanghai']);
```

打印结果

![5](D:\web前端\ES6 note\img\5.png)

```js
m.delete('name');//删除
m.get(key);//获取
console.log(m.get('change'));
```

**遍历与清空**

```js
for(let v of m){
	console.log(v);
}
m.clear();
```

### class中get和set设置

```js
let _price = 1;
class Phone(){
	get price(){
		console.log("price属性被读取了");
		return _price;
	}
	set price(newVal){
		console.log('价格属性被修改了');
        _price = newVal;	//赋值操作
	}
}
//实例化对象
let s = new Phone();
s.price = 'free'; //当更改s的price属性时，触发set price，控制台输出：价格属性被更改了
console.log(s.price); 
//当获取s的price属性，触发get price，控制台输出 price被读取了并打印出get price中return的值——即为_price值
s.price = 2;
console.log(s.price);//固定从_price读取值，但是可以通过在set里增加赋值操作通过改变_price来改变s.price

```

### async和await

async和await两种语法结合可以让异步代码像同步代码一样

#### async函数

1. async函数的返回值为promise对象
2. promise对象的结果由async函数执行的返回值决定

```js
async function fn(){
//返回一个字符串，一个数字，null，undefined等等，只要返回的结果不是一个promise类型的对象，则结果就是一个成功的promise对象
		 return 'yes';
	}
		const result = fn();
		console.log(result);
```

PromiseStatus 变成fulfilled和resolved意思差不多

![](D:\web前端\ES6 note\img\9.png)

```js
async function fn(){
//抛出错误，返回的结果是一个失败的promise
			throw new Error('出错啦');
	}
		const result = fn();
		console.log(result);
```

![10](D:\web前端\ES6 note\img\10.png)

```js
//如果返回的结果是一个Promise对象（通常是这种情况）
async function fn(){
		return new Promise((resolve,reject)=>{
				resolve('成功的数据');
			});
}
```

调用resolve之后，这个对象就会变成一个成功的promise，一旦里面成功,fn返回的结果也是成功的，且它成功的值就是函数返回的promise成功的值。

```js
async function fn(){
		return new Promise((resolve,reject)=>{
				reject('失败错误');
			});
}
```

失败同理，调用reject，这个对象就会变成一个失败的promise，里面失败，fn返回的结果也是失败的，且他失败的值就是函数返回的promise失败的值。

![11](D:\web前端\ES6 note\img\11.png)

``` js
//调用then方法
async function fn(){
			return new Promise((resolve,reject)=>{
				resolve('成功的数据');
				//reject('失败错误');
			});
		}
		const result = fn();
		//调用then方法
		result.then(value=>{
			console.log(value);
		},reason=>{
			console.warn(reason);
		})
```

第一个为成功时的结果，第二个为失败时返回的结果

![12](D:\web前端\ES6 note\img\12.png)

#### await表达式

- await必须写在async函数中

- await右侧的表达式一般为promise对象
- await返回的是promise成功的值
- await的promise失败了，就会抛出异常，需要通过try...catch捕获处理

```js
//创建promise对象	
const p = new Promise((resolve,reject)=>{
			//resolve("成功的值");
			reject("失败啦");
		})
		//await返回的结果就是promise对象成功的值
		async function main(){
			try{
				let result = await p;
				console.log(result);
			}catch(e){
				//再catch里得到失败的结果并进行一些处理
				console.log(e);	
			}
			
		}
		main();
```

**注：**await必须放在async中，但async函数中可以没有await

打印结果：

![13](D:\web前端\ES6 note\img\13.png)

#### async和await结合实践

**async和await结合读取多个文件内容**

依旧利用node.js的fs模块实现

**注：**fs时filesystem的缩写，该模块提供本地文件的读写能力，基本上时POSIX文件操作命令的简单包装。但是，这个模块几乎对所有操作提供异步和同步两种操作方式，供开发者选择。

readFile方法的第一个参数是文件的路径，第二个参数是读取完成后的回调函数，该函数的第一个参数是发生错误时的错误对象，第二个参数是代表文件内容的Buffer实例（故需要toString来转化）。

```js
	//引入fs模块
			const fs = require("fs");

			//读取 为学 
			function readweixue() {
				return new Promise((resolve, reject) => {
					fs.readFile("./为学.md", (err, data) => {
						//失败
						if (err) reject(err);
						//成功
						resolve(data);
					})
				})
			}
			//读取 观书
			function readguanshu() {
				return new Promise((resolve, reject) => {
					fs.readFile("./观书.md", (err, data) => {
						//失败
						if (err) reject(err);
						//成功
						resolve(data);
					})
				})
			}
			//读取 劝学
			function readquanxue() {
				return new Promise((resolve, reject) => {
					fs.readFile("./劝学.md", (err, data) => {
						//失败
						if (err) reject(err);
						//成功
						resolve(data);
					})
				})
			}
			//声明一个async函数
			async function main() {
				//获取为学内容
				let weixue = await readweixue();
				//获取劝学内容
				let quanxue = await readquanxue();
				//获取观书内容
				let guanshu = await readguanshu();
				console.log(weixue.toString());
				console.log(quanxue.toString());
				console.log(guanshu.toString());
			}
			main();
```

**async和await结合封装Ajax请求**

```js
	//发送AJAX请求，返回的结果是Promise对象
	function sendAJAX(url) {
		return new Promise((resolve, reject) => {
			//1.创建对象
			const x = new XMLHttpRequest();
	
			//2.初始化
			x.open('GET', url)
	
			//3.发送请求
			x.send();
	
			//4.事件绑定
			x.onreadystatechange = function() {
				if (x.readyState === 4) {
					if (x.status >= 200 && x.status < 300) {
						//成功辣
						resolve(x.response);
					}else{
						//失败
						reject(x.status);
					}
				}
			}
		})
	}
	// promise then方法测试
	// sendAJAX("https://api.apiopen.top/getJoke").then(value=>{
	// 	console.log(value);
	// },reason=>{})
	//async 和await测试
	async function main(){
		//发送AJAX请求
		//函数返回是一个promise对象
		let result = await sendAJAX("https://api.apiopen.top/getJoke");
		console.log(result);
	}
```

